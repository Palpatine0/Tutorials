![image-20210225180653045](https://i.loli.net/2021/02/25/Kxe9POwq3u5fMZ2.png)

[参考](https://www.cnblogs.com/dailyprogrammer/articles/12272717.html) [参考](https://segmentfault.com/a/1190000021045217)

例子见尚硅谷word笔记

### 六大原则⭐

**设计模式六大原则是什么？前五个为五大原则（SOLID）** [参考](https://www.jianshu.com/p/93259a886427)

**1 单一职责原则S**：就一个类而言，应该仅有一个引起它变化的原因。

> 一个方法一个类只负责一个职责，各个职责的程序改动，不影响其它程序。核心思想是解耦和增强内聚性。

**优点**

- 可以降低类的复杂度，一个类只负责一项职责，其逻辑比负责多项职责简单的多；
- 提高类的可读性，提高系统的可维护性；
- 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。

**2 开闭原则O**：对扩展开放，对修改关闭。

**优点**

- 可以使原来的测试代码依旧可以运行，只需要对扩展的代码进行测试即可
- 可以提高代码的复用性
- 可以提高系统的维护性

**3 里氏替换原则L**：任何基类可以出现的地方，子类一定可以出现。

> 子类可以扩展父类的功能，但不能改变父类原有的功能。

**包含以下4层含义：**

- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
- 子类中可以增加自己特有的方法。
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
- 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

**优点**

- 减少对象间的耦合性；
- 程序的可移植性高；
- 提高系统的可维护性。

**4 接口隔离原则I**：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

**注意以下几点：**

- 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。
- 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
- 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

**优点**

- 可以降低类之间的耦合性；
- 提高系统的灵活性和可维护性。

**接口隔离原则 VS 单一职责原则**

- 单一职责原则注重的是职责；而接口隔离原则注重对接口依赖的隔离。
- 单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。

**5 依赖倒转原则D**：抽象不应该依赖细节，细节应该依赖抽象。核心思想是面向接口编程。

**优点**

- 可以降低类之间的耦合性；
- 提高系统的稳定性；
- 降低修改程序造成的风险；
- 给多人并行开发带来了便利。

**6 迪米特原则**：一个软件实体应当尽可能少的与其他实体发生相互作用。

> 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。陌生的类最好不要作为局部变量的形式出现在类的内部。

**优点**

- 可以降低类之间的耦合性。

### 创建型模式

#### 单例模式⭐

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建；而且还提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**优点**

- 只生成一个实例，减少了系统的性能开销和内存开支；
- 可以避免对资源的多重占用；
- 可以在系统设置全局的访问点，优化和共享资源访问。

**缺点**

- 单例模式一般没有接口，扩展困难，若要扩展，除了修改代码基本上没有第二种途径可以实现；
- 若单例模式没有完成，是不能进行测试的；
- 单例类的职责过重，在一定程度上违背了“单一职责原则”。

**类图**

![这里写图片描述](https://img-blog.csdn.net/20180313112746842?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTEzNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

---

**实现** [参考](https://blog.csdn.net/horizon_junmowen/article/details/108355228?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-2&spm=1001.2101.3001.4242) [参考](https://blog.csdn.net/u011649691/article/details/89552910)

**1.1 懒汉式 synchronized**

将整个 getInstance() 方法设为同步（synchronized）。

但是它并不高效，因为在任何时候只能有一个线程调用 getInstance() 方法，而且同步操作只需要在第一次创建单例实例对象时才需要。

```java
public class Singleton{
    private static Singleton instance;
    // 加 synchronized 保证只有一个线程进入方法
    public static synchronized Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }

}
```

**1.2 懒汉式 双重检验锁模式DCL**⭐

双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法

```java
public class Singleton{
    
    // 声明成 static volatile
    private static volatile Singleton instance;
    
    // 私有，使外界构造方法失效
    private Singleton(){
		
    }
    
    // 声明成 static
    public static Singleton getInstance(){
        // 非空时直接返回
        if(instance == null){
            synchronized(Singleton.class){
                // 防止生成多个实例
                if(instance == null){
                     instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**为什么要两个if？**

- 第一次**非空时直接返回**：检查对象是否实例化，实例化过则直接返回对象；去掉则synchronized浪费性能
- 第二次**防止生成多个实例**：对象未实例化时，可能会有多个线程进入同步块外的 if，如果不进行二次检验的话就会破坏单例

**为什么要用static修饰**⭐

- getInstance() 方便通过Singleton.getInstance()创建对象
- instance 因为getInstance() 方法是static的，只能引用静态对象

**为什么instance要用volatile修饰**

instance = new Singleton() 并非原子操作，在 JVM 中步骤为：

1. 给 instance 分配内存
2. 调用 Singleton 的构造函数来初始化成员变量
3. 将 instance 指向分配的内存空间，此时instance非空

在 JVM 中指令可能发生重排序，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，且在 3 执行完毕、2 未执行之前，instance  被线程二抢占，由于这时 instance 已经非 null ，所以线程二会获得未初始化的 instance ，发生错误。这个就是著名的**DCL失效问题**。

可以使用volatile的**有序性**解决这个问题，对指令加上内存屏障，使得 volatile 变量的写操作都先于读操作

**1.3 懒汉式 静态内部类**⭐

《Effective Java》上所推荐

```java
public class Singleton{
    // 静态内部类只会被加载一次，故 instance 单例且线程安全
    private static class SingletonHolder {
        private static final Singleton instance = new Singleton();
    }
    // getInstance()方法调用时才加载静态内部类
    public static final Singleton getInstance(){
        return SingletonHolder.instance;
    }
}
```

**原理**⭐ [参考](https://blog.csdn.net/weixin_39955351/article/details/111009055)

- JVM 有5个类加载时机，而静态内部类不在其中。故静态内部类是懒加载，getInstance() 方法调用时才加载。
- 静态内部类只会被加载一次，故 instance 单例且线程安全。虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，而且唤醒之后不会再次进入<clinit>()方法。故同一个加载器下，一个类型只会初始化一次。

**缺点**

传参问题：由于采用静态内部类去创建单例，故外部无法传递参数。

**2 饿汉式 static final field**

- static：第一次加载类到内存中时就会初始化
- final ：保持引用变量instance指向值不变

```java
public class Singleton{
    // 饿汉式
    private static final Singleton instance = new Singleton();
    public static Singleton getInstance(){
        return instance;
    }
}
```

**缺点**

不是懒加载

**3 枚举 Enum**

最大的优点是简单，创建枚举默认就是线程安全的

```java
public class Singleton{
    /**
     *枚举类型是线程安全的，并且只会装载一次
     */
    public enum SingletonEnum{
        INSTANCE;
        private final Singleton instance;
        SingletonEnum(){
            instance = new Singleton();
        }
        private Singleton getInstance(){
            return instance;
        }
    }

    public static Singleton getInstance(){
        return SingletonEnum.INSTANCE.getInstance();
    }
}
```

#### 简单工厂模式⭐

简单工厂模式又叫静态工厂方法模式（但不属于23种设计模式），就是建立一个工厂类，实现了对同一接口的类进行实例化创建。

比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可。

**优点**

- 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪个产品类的实例；客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；通过这种做法实现了对责任的分割
- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数（如类别）即可
- 通过引入配置文件，可以在不修改客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

**缺点**

- 不易拓展，一旦添加新的产品类型，就不得不修改工厂的创建逻辑；
- 产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。

**类图** [参考](https://www.cnblogs.com/toutou/p/4899388.html)

<img src="https://images2015.cnblogs.com/blog/506684/201510/506684-20151022143920099-1114959445.png" alt="C# 简单工厂模式" style="zoom: 67%;" />

- 工厂类（Factory）：根据内部逻辑返回相应的产品
- 抽象产品类（Product）：提供抽象方法供具体产品类实现
- 具体产品类（ConcreteProduct）：提供具体的产品，一般有很多个

#### 工厂方法模式⭐

工厂方法模式一般定义一个用于创建对象的接口，让子类决定实例化哪一个类，**使得一个类的实例化延迟到其子类**。（与简单工厂相比）

**优点**

- 具有良好的封装性，代码结构清晰。只要知道产品的类名，而不需要知道创建对象的过程，降低模块间的耦合；
- 具有很好的扩展性。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类即可
- 屏蔽产品类。调用者只需关心产品的接口，只要接口保持不变，系统中的上层模块就不需要变化；
- 该模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则；只依赖产品类的抽象，符合依赖倒置原则；可以使用产品子类替换产品父类，符合里式替换原则。

**缺点**

- 类的个数容易过多，增加复杂度
- 增加了系统的抽象性和理解难度

**类图** [参考](https://www.cnblogs.com/toutou/p/4899388.html)

<img src="https:////upload-images.jianshu.io/upload_images/5733856-9aa49cfed389a906.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:67%;" />



<img src="https://images2015.cnblogs.com/blog/506684/201510/506684-20151022154920192-885506749.png" alt="C# 工厂方法模式" style="zoom:67%;" />

- 抽象工厂类（Factory）：提供抽象方法供具体工厂实现
- **具体工厂类**（ConcreteFactory）：提供具体的工厂（相比简单工厂多出的对象）
- 抽象产品类（Product）：提供抽象方法供具体产品类实现
- 具体产品类（ConcreteProduct）：提供具体的产品

#### 抽象工厂模式⭐

抽象工厂模式为创建**一组相关或相互依赖的对象**（意味着多个基类产品）提供一个接口，而且无需指定他们的具体类

比如，以上面的咖啡工厂为例，某天我的口味突然变了，不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。这个时候就可以使用抽象工厂类了，抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。

**优点**

- 隔离了具体类的生成，使得客户并不需要知道什么被创建，具有良好的封装性。
- 横向扩展容易。同个产品族如果需要增加多个产品，只需要增加新的工厂类和产品类即可。

**缺点**

纵向扩展困难。如果增加新的产品组，抽象工厂类也要添加创建该产品组的对应方法，这样一来所有的具体工厂类都要做修改了，严重违背了开闭原则。 

**类图** [参考](https://www.cnblogs.com/toutou/p/4899388.html)

![img](https://images2015.cnblogs.com/blog/506684/201510/506684-20151022224134770-1030212239.jpg)



- AbstractFactory：用于声明生成抽象产品的方法
- ConcreteFactory：实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；
- AbstractProduct：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；
- Product：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。

**简单工厂、工厂模式、抽象工厂模式的区别？**

- 简单工厂只有**一个具体工厂类**来生产**一种基类的多个派生类产品**
- 工厂方法是有**多个具体工厂类**，都派生于一个基类即抽象工厂类，每个具体工厂类只生产**一种基类的一个派生类产品**
- 抽象工厂也有**多个具体工厂类**，都派生于一个基类即抽象工厂类，每个具体工厂类只生产**多种基类的一个派生类产品**（相关联）

举例子 [参考](http://www.360doc.com/content/11/1019/21/4619459_157554590.shtml) ：个人觉得这个区别在于产品，如果产品单一，最合适用工厂模式；是如果有多个业务品种、业务分类时，用抽象工厂模式更好。再通俗深化理解下：工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。

### 结构型模式

#### 代理模式⭐

代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。

举一个生活中的例子：比如买飞机票，由于离飞机场太远，直接去飞机场买票不太现实，这个时候我们就可以上携程 App 上购买飞机票，这个时候携程 App 就相当于是飞机票的代理商。

**优点**：

- 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；
- 可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。

**缺点**：

- 由于使用了代理模式，因此程序的性能没有直接调用性能高；
- 使用代理模式提高了代码的复杂度。

**类图** 

![这里写图片描述](https://img-blog.csdn.net/20180314172944524?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3UwMTE0NzUxMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![image-20210226232453497](https://i.loli.net/2021/02/26/kMeNT2RsEhz7BUw.png)

- Subject 抽象主题角色：可以是抽象类也可以是接口，是一个最普通的业务类型定义。
- RealSubject 具体主题角色：是业务逻辑的具体执行者。
- Proxy 代理主题角色：负责对真实角色的应用，把所有抽象主题角色定义的方法委托给具体主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后处理工作。

#### 适配器模式

适配器模式将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作，通常用来解决接口不相容的问题。

以生活中的例子来说，比如有一个充电器是 MicroUSB 接口，而手机充电口却是 TypeC 的，这个时候就需要一个把 MicroUSB 转换成 TypeC 的适配器，

**优点**

- 可以让两个没有任何关系的类一起运行。通过把非本系统接口的对象包装成本系统可以接受的对象，降低了系统大规模变更的风险；
- 增加了类的透明度。访问的Target目标角色的具体实现都委托给了源角色，这些对高层次模块是透明的，也是它不需要关心的；
- 提高了类的复用度。源角色在原有系统中还是可以正常使用，而在目标角色中也可以充当新的演员；
- 灵活性好。适配器基本上类似一个灵活的构件，想用就用，不想用就卸载。

**缺点**

过多地使用适配器，容易使代码结构混乱，如明明看到调用的是 A 接口，内部调用的却是 B 接口的实现。

**类图**

![这里写图片描述](https://img-blog.csdn.net/20180504215355169?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0NzUxMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- Target 目标角色：该角色定义把其他类转换为何种接口，也就是我们期望接口。
- Adaptee 源角色：它是已经存在的、运行良好的类或对象，经过适配器角色的包装，从而转换成目标角色。
- Adapter 适配器角色：适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的。它的职责非常简单：通过继承或是类关联的方式，把源角色转换为目标角色。

**适配器模式和代理模式之间有什么不同？**

- 由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的
- 但是他们的意图不同。适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。

#### 装饰器模式

装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。装饰器模式的关键：装饰器中使用了被装饰的对象。

比如，创建一个对象“laowang”，给对象添加不同的装饰，穿上夹克、戴上帽子......，这个执行过程就是装饰者模式，

**优点**

装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

**类图**

![这里写图片描述](https://img-blog.csdn.net/20180326135016765?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0NzUxMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- Component 抽象构件：一个接口或者是抽象类，最核心的对象。
- ConcreteComponent 具体构件：最核心的接口或抽象类的实现。
- Decorator 装饰角色：一般是一个抽象类，实现接口或者抽象方法，且属性里有一个private变量指向Component抽象构件。

- ConcreteDecorator 具体装饰角色：把最核心对象装饰成其他对象。

**适配器模式与装饰器模式有什么区别？**

结构类似，但出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不改类的情况下给类增加新的功能。

- 装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。
- 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。

**代理模式和装饰器模式的区别**



### 行为型模式

#### 策略模式⭐

策略模式是指定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。

以生活中的例子来说，比如我们要出去旅游，选择性很多，可以选择骑车、开车、坐飞机、坐火车等，就可以使用策略模式，把每种出行作为一种策略封装起来，后面增加了新的交通方式了，如超级高铁、火箭等，就可以不需要改动原有的类，新增交通方式即可，这样也符合软件开发的开闭原则。

**优点**

- 算法可以自由切换。只要实现抽象策略，它就成为策略家族的一员，通过封装角色对其进行封装，保证对外提供可自由切换的策略；
- 避免使用多重条件判断。使用策略模式后，可以由其他模块决定采用何种策略
- 扩展性良好。在现有的系统中增加一个策略，只要实现接口就可以，其他都不用修改

**缺点**

- 策略类数量增多。每一个策略都是一个类，复用的可能性很小，类数量增多；（每个小对象要选择一种具体的策略）
- 所有的策略类都需要对外暴露。上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，与迪米特法则违背（但可以使用其他模式来修正这个缺陷，如工厂方法模式、代理模式或享元模式。）

**使用场景**

- 多个类只有在算法或者行为上稍有不同的场景；
- 算法需要自由切换的场景；
- 需要屏蔽算法规则的场景。

**类图**

![这里写图片描述](https://img-blog.csdn.net/20180327132741306?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0NzUxMzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![image-20210226122118449](https://i.loli.net/2021/02/26/JViSTeHlbLxOBk5.png)

- Context 封装角色：也叫上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。
- Strategy 抽象策略角色：策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。
- ConcreteStrategy 具体策略角色：实现抽象策略中的操作，包含具体的算法。

#### 模板模式

模板方法模式是指定义一个模板结构，将具体内容延迟到子类去实现。

**优点**

- 模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。
- 子类实现算法的某些细节，有助于算法的扩展。
- 通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合开闭原则。

**类图**

​                                                            <img src="https://images2015.cnblogs.com/blog/1072224/201705/1072224-20170514212336441-866709229.png" alt="img" style="zoom:67%;" />

- 抽象父类（AbstractClass）：实现了模板方法，定义了算法的骨架。
- 具体类（ConcreteClass)：实现抽象类中的抽象方法，即不同的对象的具体实现细节。

#### 观察者模式

观察者模式是定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 

**优点**

- 可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种不同的表示层作为具体观察者角色；
- 在观察目标和观察者之间建立一个抽象的耦合；
- 支持广播通信；
- 符合开闭原则（对拓展开放，对修改关闭）的要求。

**缺点**

- 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间；
- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；
- 没有相应的机制让观察者知道目标对象是怎么发生变化的

**类图**

![img](https://img2018.cnblogs.com/blog/1018770/201905/1018770-20190523171217163-733072511.png)

- Subject：抽象主题（抽象被观察者），把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者。提供一个接口，可以增加和删除观察者对象；
- ConcreteSubject：具体主题（具体被观察者），**将有关状态存入具体观察者对象**，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知；
- Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己；
- ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，使得在得到主题更改通知时更新自己；

### 应用实例⭐

**Spring中都用到了哪些设计模式？**

- 单例模式：Bean默认为单例模式
- 工厂模式：BeanFactory是简单工厂模式的体现，用来创建对象实例



- 代理模式：AOP功能用到了JDK的动态代理和CGLIB字节码生成技术
- 适配器模式：AOP 的增强或通知，SpringMVC 中的Controller
- 装饰器模式：项目需要连接多个数据库时，可以根据客户的需求动态切换不同的数据源



- 模板方法：解决代码重复问题。如RestTemplate, JmsTemplate, JpaTemplate
- 观察者模式：事件驱动模型，如ContextStartedEvent 就是 ApplicationContext 启动后触发的事件

**JDK 中用到了哪些设计模式？** [参考](https://blog.csdn.net/wangpengzhi19891223/article/details/81181468)

-  单例模式：用于Runtime，Calendar和其他的一些类中。

- 工厂模式：被用于各种不可变的类如Boolean，像Boolean.valueOf，Proxy.newProxyInstance()

- 抽象工厂模式：用于java.util.Arrays.asList()  java.sql.Connection.createStatement()

- 建造者模式：定义了新的类构建另一个类的实例，简化复杂对象的创建。通常也使用方法链接实现

  java.lang.StringBuilder#append() 



- 代理模式：用一个简单的对象来代替一个复杂的或者创建耗时的对象。java.lang.reflect.Proxy
- 适配器模式：**InputStream** 字节流不能享受到字符流读取字符的便捷功能，可借助 InputStreamReader 将其转为 Reader 子类
- 装饰器模式：**InputStream** 字节流包装为其他流，如 FileInputStream、ByteArrayInputStream、PipedInputStream 



- 策略模式：如重写Array数组的排序规则 java.util.Comparator#compare()
- 模板方法模式：让子类可以重写方法的一部分，而不是整个重写。java.util.Collections#sort()

- 观察者模式：被用于Swing和很多的事件监听中。
