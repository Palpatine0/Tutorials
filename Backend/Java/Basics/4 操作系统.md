### 进程与线程

**重要术语**

- 并发：同一时间段多个程序轮流发生。多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。并发的两种关系是同步和互斥

  - 同步：进程间存在依赖关系，需**协调进程的执行顺序**。如一个进程结束的输出作为另一个进程的输入

    > 异步：进程间彼此独立。在等待某个事件的过程中继续做自己的事，不要等待这一事件完成后再工作

  - 互斥：进程间访问临界资源时相互排斥

- 并行：同一时刻多个程序同时发生

  > 串行：程序由一个线程按顺序执行


#### 进程⭐

**进程在内存中的结构**

- 代码区：存放机器指令。可共享、只读
- 数据区：存放已初始化的全局变量、静态变量、常量
- BSS区：存放未初始化的全局变量
- 堆区：存放对象。由程序员分配释放（malloc()函数、free()函数），容易产生内存泄漏
- 栈区：存放方法的局部变量、参数值、返回值。由编译器自动分配释放，无须程序员手动管理。

![这里写图片描述](https://www.icode9.com/img/?i=20180911193455431)

**进程有哪几种状态**⭐

- 创建态：创建态的进程要进入就绪态需要经过很多步骤（如申请PCB），当这些步骤未能完成时，就处于创建态。
- 就绪态：创建态的进程完成创建步骤，进程就进入就绪状态，等待分配CPU时间。
- 执行态：就绪态的进程获得调度时，就进入执行态；当CPU时间片完后，若进程工作仍未结束，则回到就绪态。
- 阻塞态：执行态的进程受到更高优先级进程影响时，会进入阻塞态；等待更高优先级进程执行完毕，再回到就绪态
- 终止态：执行态的进程完成所有工作后，就会释放资源，进入终止态。

<img src="https://i.loli.net/2021/01/01/Pyape65vmwsFoNk.png" alt="img" style="zoom:80%;" />

**进程同步机制遵循的原则**

- 空闲让进：临界区空闲时，可允许一个请求进入临界区的进程进入临界区
- 忙则等待：已有进程进入临界区时，所有请求进入临界区的进程必须等待
- 有限等待：请求进入临界区的进程，应保证其能在有限时间内进入临界区
- 让权等待：请求进入临界区的进程不能进入临界区时，应释放处理机

**进程间通信有哪些方式？它们的区别？⭐**

进程通信指进程之间的信息交换，通过原语实现。低级通信：信号量；高级通信：共享内存、管道、消息队列；

> **原语**：若干机器指令构成的，用以完成特定功能的一段程序。其主要特点是不可分割性

- 信号（signal）：通知进程某一事件发生。只能用来同步，不能传递复杂信息。
- 信号量（semophere）：一个计数器，用来控制多个进程对共享资源的访问。通常作为一种锁机制。
- 共享内存（shared memory）：一段能被进程访问的共享内存，往往与其他通信机制配合使用。能够很容易控制容量，速度最快；但要保持同步，注意读写问题，相当于线程中的线程安全。
- 管道：连接一个写进程和一个读进程，以生产者—消费者方式通信的一个共享文件，又称为pipe文件
  - （无名）管道（pipe）：半双工通信，只能在父子进程间使用。
  - 命名管道（named pipe）：半双工通信，但是允许无亲缘关系进程间使用。
- 消息队列（message queue）：由消息组成的链表，存放在内核中，并由消息队列标识符标识。克服了信号传递消息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点；容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
- 套接字（socket）：与其他通信机制不同的是可用于不同机器间进程的通信。

|                                                          | 同一机器两个进程间通信 | 跨网络通信 |
| -------------------------------------------------------- | ---------------------- | ---------- |
| 共享存储器系统（剪贴板Clipboard）                        | 可以                   | 不可以     |
| 匿名管道Pipe                                             | 可以                   | 不可以     |
| 命名管道（点对点单一通信，数据量可较大）Namedpipe        | 可以                   | 可以       |
| 消息队列 邮槽（一对多，数据量较小，424字节以下）Mailslot | 可以                   | 可以       |

#### 程序 进程 线程 协程⭐

**进程与程序的区别**

- 程序是指令的有序集合；进程是由……组成。
- 程序是一个静态概念；进程是一个动态概念，是程序的一次执行过程。
- 程序的存在是永久的；进程的存在是有生命周期的。
- 进程与程序之间不是一一对应，即同一程序运行于若干不同的数据集合上，它将属于不同的进程；而一个进程可以执行多个程序。

**进程与线程的区别**⭐

- 引入进程是为了让程序并发执行，提高资源利用率和系统吞吐量；引入线程是为了让进程并发执行，提高进程的并发能力

- 进程是资源分配的基本单位；线程是CPU调度和分派的基本单位；

- 进程有自己独立的地址空间；线程没有独立的地址空间，使用相同的地址空间共享数据

- 进程更安全，一个进程死掉不会影响另一个进程（独立地址空间）；线程不易维护，一个线程死掉整个进程就死掉（共享地址空间）

- 进程切换开销大；线程切换开销小

  > 进程对资源保护要求高，开销大，效率相对较低；线程资源保护要求不高，开销小，效率高；
  >
  > 线程之间通信更方便，同一个进程下，线程能共享全局变量，静态变量等数据；进程通信则需以通信的方式进行

**进程 线程 协程**⭐

- 协程仅仅是一个特殊的**函数**，完全由程序控制，在用户态执行。
- 一个进程可以包含多个线程，一个线程可以包含多个协程，都存在上下文切换问题
- 多个协程在一个线程中**串行执行**，没法利用CPU多核能力。但不会因线程切换消耗资源，性能大幅提升

---

**什么是上下文切换？**

任务从保存到再加载的过程就是一次上下文切换。任务在切换之前会**保存**上一个任务的状态（上下文），回来后会再**加载**这个状态

**(CPU)上下文切换三种类型** [参考](https://www.jianshu.com/p/1c80cd47e8cf)

- 进程上下文切换
- 线程上下文切换
- 中断上下文切换

**为什么线程切换比进程切换开销小，上下文都有哪些内容**⭐ [参考](https://www.cnblogs.com/yvkm/p/10619001.html) [参考](https://zhidao.baidu.com/question/132198039.html)

线程共享进程内存空间，故线程上下文是进程上下文的**子集**，故线程切换开销更小。

- 进程上下文：程序计数器、寄存器、栈、堆、程序的代码和数据、打开的文件描述符的集合等
- 线程上下文：程序计数器、寄存器、栈、线程ID

#### 用户态 内核态⭐

**内核概念**

内核是操作系统最核心的部分，负责调度cpu，管理进程和内存等，用户程序操作硬件资源必须通过内核这个中间层

- 内核态：CPU可以访问内存所有数据
- 用户态：CPU只能受限的访问内存数据，不允许访问外围设备。

**操作系统为什么要设置用户态和内核态？**

限制不同程序的访问能力，防止他们获取其他程序或外围设备的数据，保证操作系统的安全性。

假设没有内核态和用户态之分，程序就能随便访问硬件资源。如分配内存时，程序员一不小心将不适当的内容写到了不该写的地方，就很可能导致系统崩溃。

**哪些操作会从用户态切换到内核态？**⭐  [参考](https://blog.csdn.net/qq_39823627/article/details/78736650?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)

- 系统调用：进程主动要求从用户态切换到内核态的方式。六大类：**进程控制、文件管理**、设备管理、信息维护、通信、保护。[参考](http://c.biancheng.net/view/1196.html)
- 异常：执行用户态程序时发生了不可预知的异常，会切换到处理此异常的内核程序中，进入内核态。如缺页异常。
- 外围设备的中断：外围设备（内核态）处理完用户请求后，会向CPU发出中断信号，使得CPU会暂停执行当前程序转而去执行中断对应的程序。若先前执行的是用户态程序，那么就发生了由用户态到内核态的切换。如硬盘读写操作完成

**进程哪些通信方式是要陷入内核态的**

![image-20210303162954985](https://i.loli.net/2021/03/03/27QLbYrqv4C5uGw.png)

其他的不知道了

### 调度与死锁

#### 调度

**处理器的三级调度**

- 高级调度（作业调度）：将处于外存后备队列的作业放入内存就绪队列
- 低级调度（进程调度）：将处于内存就绪队列的进程放入CPU中运行，**运行频率最高，最基本的调度**
- 中级调度（内存调度）：将外存对换区具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待。内存中暂时不能运行的进程对换到外存兑换区，此时状态为挂起状态。

**进程的调度算法有哪些？**

- 先来先服务（FCFS）：按进程进入就绪队列的次序调度
- 优先级调度算法：按照进程的优先级的大小调度。
- 短进程优先（SPF）：优先运行时间最短的进程
- 高响应比优先：按照高响应比**（等待时间+运行时间）/运行时间** 优先的原则，每次计算进程的响应比RP，选择最大。
- 时间片轮转法：每个进程每次最多执行一个时间片，时间片用完时便终止该进程的执行，并将它送到就绪队列的末尾。然后把处理机分配给就绪队列中的队头进程。
- 多级队列调度法：将就绪队列再分为若干个队列，不同的就绪队列采用不同的调度算法。

#### 死锁⭐

死锁是指多个进程因竞争资源而造成的一种僵持状态。若无外力作用，这些进程都将永远处于阻塞状态，不能再运行下去。                

**两个原因 **

- 竞争资源：请求资源的进程多于可用资源数
- 推进顺序非法：进程执行中请求和释放资源的顺序不合理，如资源等待链

**四个必要条件**

- 互斥条件：一个资源一次只能被一个进程使用
- 请求与保持条件：进程请求资源阻塞时，已获得的资源保持不放
- 不可抢占条件：进程已获得的资源在使用完之前不能强行剥夺
- 环路等待条件：进程之间形成一种头尾相接的循环等待资源关系

---

**四种处理策略和方法**

**1 死锁预防**⭐

只要死锁发生的四个必要条件中有一个不成立，就能预防死锁的发生

- 互斥条件：是非共享资源并发执行的必要条件，非但不能禁止，反而应该保证

- 请求和保持：**一次性申请所需的全部资源**

  缺点：资源浪费严重，利用率低下；

- 不可抢占：请求资源阻塞时，**若再申请其他资源，必须把原有资源释放**

  缺点：实现复杂；反复地申请和释放资源，进程的执行被无限推迟；增加系统开销、降低系统吞吐量。

- 环路等待：将资源按类型进行线性排队，并赋予不同的序号。**必须按资源递增的顺序请求资源**，防止出现环路。

  缺点：序号必须相对稳定，限制了新设备类型的增加；限制了用户编程；进程使用资源顺序和系统规定的顺序不同而造成资源的浪费

**2 死锁避免**⭐

动态地检测资源分配状态，确保循环等待条件不成立，系统处于安全状态。

> 安全状态指如果存在一个安全序列（进程运行顺序），那么系统安全。

- **银行家算法**：应用于每种资源类型可以有多个实例的场景。……
- 资源分配图算法：应用场景为每种资源类型只有一个实例（申请边，分配边，需求边，不形成环才允许分配）

**3 死锁检测**

保存资源的请求和分配信息，并采用算法检测系统是否已进入死锁状态。

**4 死锁解除**

- 进程终止：简单地终止一个或多个进程以打破循环等待。包括两种方式：
  - 终止所有死锁进程
  - 一次只终止一个进程直到取消死锁循环为止；
- 资源抢占：从一个或多个死锁进程那里抢占一个或多个资源，此时必须考虑三个问题：
  - 选择一个牺牲品
  - 回滚：回滚到安全状态
  - 饥饿（在代价因素中加上回滚次数，回滚的越多则越不可能继续被作为牺牲品，避免一个进程总是被回滚

### 存储器管理

#### 分页

**页式管理的基本原理是什么?**

- 内存分为等长的块（块可以不相邻）；作业分为与块等长的页
- 页表记录了页号到块号的映射，实现逻辑地址到物理地址的转换（重定位）

<img src="https://img-blog.csdnimg.cn/20190803105838798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 33%;" />

**页表 快表**

页表存储在内存中，访问分页系统中内存数据需要两次的内存访问(一次是从内存中访问页表，根据逻辑地址算出物理地址；第二次是根据的物理地址访问内存取出数据)。

快表是存放在高速缓冲存储器的页表，起与页表相同的作用。采用页表做地址转换要访问**两次主存**。快表只要访问**一次高速缓冲存储器，一次主存**，这样可加速查找并提高指令执行速度。

#### 分段

**段式管理的基本原理是什么?**

- 内存和作业分为不等长的段
- 段表记录了段号、段长和基址，实现逻辑地址到物理地址的转换（重定位）

<img src="https://img-blog.csdnimg.cn/20190803105911822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 33%;" />

**段表**

段表也是**两次内存访问**（一次是从内存中访问段表，根据逻辑地址算出物理地址；第二次是根据物理地址访问内存取出数据）

分段管理中同样可以引入高速缓冲存储器。

---

**分页分段区别⭐**

- 目的不同：分页是系统管理的需要（提高内存利用率）；分段是用户的需要（如数据共享，数据保护，动态链接等）
- 大小不同：页的大小固定且由系统决定；段的大小不固定且由功能决定
- 地址不同： 页是一维地址空间，指令连续；段是二维地址空间，指令不连续 （地址=号+偏移，而段大小不一 [参考](https://blog.csdn.net/yangkuiwu/article/details/53493458)）
- **内存碎片**：页式管理有内碎片（一个页可能填充不满），没有外碎片（全部空间平分为固定大小的页，充分使用）；段式管理有外碎片（比如4k的段换5k的段，会产生1k的外碎片无法使用），没有内碎片（因为段大小可变，改变段大小来消除内碎片）

#### 地址

**操作系统有多少种地址？** [参考](https://blog.csdn.net/leves1989/article/details/3305402?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&dist_request_id=1330147.26222.16181573698122695&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control) [参考](https://www.bilibili.com/read/cv8114824/)

逻辑地址 ----（段表）---> 线性地址 — （页表）—> 物理地址

- 逻辑地址：程序中与段相关的偏移地址。形式为[段标识+段内偏移量] 
- 线性地址：逻辑地址加上段基址。
- 物理地址：机器中实际的内存地址。若没有启用分页机制，则线性地址就是物理地址；如果启用了分页机制，则MMU可查询页表将线性地址转为物理地址
- 虚拟地址：有时也把逻辑地址称为虚拟地址。因为逻辑地址也与实际物理内存容量无关。

**虚拟内存怎么把虚拟地址转化为真实地址 / 虚拟内存系统寻址过程**

与体系结构相关，一般来说有分段、分页两种方式

- 由**MMU**（CPU内存管理单元）负责虚拟地址到物理地址的转化：
- MMU通过查询段表把逻辑地址转化为线性地址
- 若没有启用分页机制，则线性地址就是物理地址；若启用了分页机制，则可通过MMU查询页表将线性地址转为物理地址

### 虚拟内存

#### 设计原理

**局部性原理是虚拟存储器的理论基础**

- 时间局部性：被访问的页不久的将来很可能被访问；
- 空间局部性：被访问的页周围的页也很可能被访问。

**基本思想**

- 进程被分为大小相等的多个页
- 虚拟内存不要求进程完全在内存中。内存中的页叫物理页，磁盘中的页叫虚拟页（占用硬盘空间），物理页+虚拟页是系统所有页的总和。这样系统逻辑上有很大的空间
- 程序引用物理页时，直接使用；引用虚拟页时，（内存不足时）发生缺页中断并使用页面置换算法将页调入内存。

<img src="https://i.loli.net/2021/04/11/t9xXwbSQJc7i546.png" alt="image-20210411131102010" style="zoom:67%;" />

**特征**

虚拟性建立在多次性和对换性的基础上，多次性和对换性又建立在**离散分配**的基础上。

- 多次性： 一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性

- 对换性： 作业运行过程中存进换出(换出暂时不用的数据换入需要的数据)

- 虚拟性： 虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。最重要特征也是其最终目标

**优点**

- 进程可以比内存还大，解除了用户与内存之间的紧密约束
- 在内存中可以保留多个进程，系统并发度提高

**缺点**

性能肯定比不上纯内存，缺页中断会发生用户态到内核态的切换

#### 页面置换

**页面置换算法**

- FIFO 先进先出算法：换出最先进入的页
- LRU（Least recently use）最近最少使用算法：换出最早使用的页
- LFU（Least frequently use）最少使用次数算法：换出最少使用次数的页
- OPT（Optimal replacement）最优置换算法：换出将来不再使用或最晚使用的页

**颠簸 / 抖动**

指频繁的页调度行为，不断产生缺页中断，导致整个系统的效率急剧下降。解决策略包括：

- 修改页面替换算法
- 增加物理内存容量
- 降低多道程序的数量
- 终止该进程

### 输入输出

#### 中断 轮询

**什么是中断？中断时CPU做什么工作？什么是轮询？**

- 中断：运行时发生了急需处理的事件，使得CPU暂时中断当前程序而去执行中断信号所对应的程序，待处理完后返回原来中断处继续执行或调度新的进程。

  CPU利用率高；但响应速度慢

- 轮询：CPUI定时轮流询问各个设备有无处理要求，有则加以处理。

  响应速度快；但CPU利用率低

**键盘按下一个键，之后发生了什么？** [参考](https://blog.csdn.net/idevede/article/details/53188542?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control)

- 键盘被按下后产生硬件**中断信号**
- 计算机高级中断控制器（IOAPIC）选择CPU处理核心以及软件中断编号，并发送给中断描述符表（IDT）处理
- 计算机根据IDT选择中断处理函数
- 处理函数处理并通知端口驱动获取按键信息
- 端口驱动将数据封装，以IRP（I/O request package）形式传递给上层处理程序
- 等待输入的进程获得数据，处理并交给目标进程
- 目标进程显示输入

### Linux

#### Linux进程⭐

**linux最先启动的3个进程是什么** [参考](https://blog.csdn.net/BigBug_500/article/details/103544253)

- idle进程(PID = 0)：由系统自动创建，运行在内核态。唯一一个没有通过 kernel_thread 或 fork() 创建的进程
- init进程(PID = 1)：由 idle 进程通过 kernel_thread 创建，在内核态完成初始化后会进入用户态。**系统中所有用户进程的父进程**（使用 fork() ），能创建其他用户进程并作为守护进程监视它们。
- kthreadd(PID = 2)：由 idle 进程通过 kernel_thread 创建，运行在内核态。负责所有内核线程的调度和管理

**Linux的进程状态有哪些** [参考](https://blog.csdn.net/sdkdlwk/article/details/65938204)

- R（可运行态）：进程处于正常操作系统的就绪态和运行态
- S（可中断睡眠态）：进程因等待事件而被挂起，可中断（如等待socket连接、等待信号量）
- D（不可中断睡眠态）：进程因等待事件而被挂起，但不可中断（如内核）
- T（暂停态或跟踪态）：进程收到SIGSTOP信号或被跟踪
- Z（僵尸态）：进程为僵尸进程
- X（死亡态）：进程被销毁

**常考进程类别**

- 孤儿进程：父进程先于子进程退出，子进程就变成了孤儿进程。孤儿进程会被1号init进程收养，即1号进程变成孤儿进程的父进程
- 僵尸进程：子进程先于父进程退出，但父进程没有调用wait或waitpid获取子进程的退出状态，使得子进程的PCB一直驻留在内存，变成僵尸进程。浪费资源

> wait()函数功能是：父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。

---

**Linux是如何创建进程的**⭐ [参考](https://blog.csdn.net/qq_32693119/article/details/87860128) [参考](https://yngzmiao.blog.csdn.net/article/details/81193118?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control)

fork()和vfork()是无参数的，而clone()则带有参数

fork()是全部复制，vfork()是共享内存，而clone() 是则可以将父进程资源有选择地复制给子进程

**1 系统调用fork()**⭐

- 将父进程数据区和堆栈区的内容复制给子进程（子进程控制块必须要有表示自己的私有空间），将子进程指针指向父进程代码（父子进程运行同一程序）

- 成功复制时fork()返回两个值，父进程返回子进程的进程号，子程序返回零

<img src="https://img-blog.csdn.net/20180724220015528?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNzMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom: 67%;" />

**系统调用execv()**

通常调用execv()的都是子进程，是子进程执行新程序的手段之一。调用execv()后，系统会为子进程加载可执行文件并分配单独的物理空间，从此子进程也成为一个真正的进程。

> 原型为`int execv(const char* path, char* const argv[]);` 其中，参数path为可执行文件路径，argv[]为命令行参数。该函数会把函数参数path指定的可执行文件加载到进程的用户内存空间，并覆盖掉原文件，然后运行这个新加载的可执行文件。

**假设操作系统内存是4GB，有2.5GB被A进程占用了，操作系统本身占用0.5GB内存。这时候如果fork了这个进程，是否能成功，为什么**

可以，由于COW，两个进程应该合起来比2.5GB多一些（子进程控制块必须要有表示自己的私有空间）

**2 系统调用vfork()**

- 子进程与父进程完全共享地址空间
- 父进程返回子进程的进程号，子进程返回0 

**写时拷贝技术copy-on-write / COW** [参考](https://blog.csdn.net/this_is_me_anyway/article/details/79553723?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242)

写时拷贝是一种可以推迟甚至避免数据拷贝的技术。创建进程时内核并不会进行复制，而是让子进程与父进程以只读方式共享空间。只有在地址空间需要写入时才会复制，有了写时复制后vfork的意义其实就不大了。 

**vfork()的好处 / 写时拷贝技术的好处** 

传统的fork()直接把所有的资源复制给新进程，过于简单并且效率低下，而且若一开始就打算创建一个不同的子进程，则所有的拷贝都将前功尽弃。

**3 系统调用clone()**

- clone()有参数，可将父进程资源有选择地复制给子进程，其他资源通过指针与子进程共享
- 返回子进程的pid

#### 文件系统⭐

**简述Linux 文件系统？**

在 Linux 系统中有一个重要的概念：一切都是文件。

<img src="https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYzIuaW9jb2Rlci5jbi9iNjg2NTQxN2RkMTI0NWU0ZjNjNGJhODc3Y2U5YzVhYQ?x-oss-process=image/format,png" alt="文件类型" style="zoom: 67%;" />

**Linux 的目录结构是怎样的？**
                                  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYzIuaW9jb2Rlci5jbi81YzJmNTRmMjhkNGVhYmJlMTM4ZmQ4Y2JiNzYzYTFmMQ?x-oss-process=image/format,png" alt="Linux的目录结构" style="zoom:80%;" />

- **/bin**： 存放二进制可执行文件(ls,cat,mkdir等)，如常用命令；
- **/etc**： 存放系统管理和配置文件；
- **/usr **：存放系统应用程序；
- **/lib **： 存放系统运行相关的库文件 ；
- **/dev**：存放设备文件；
- **/home**：存放所有用户文件的根目录，如用户user的主目录就是/home/user，可以用~user表示；
- **/root**：存放超级用户（系统管理员）的主目录（特权阶级o）；
- **/opt**：存放安装的应用程序包。一般情况下，我们可以把tomcat等都安装到这里；
- **/tmp**：存放各种临时文件，是公用的临时文件存储点；
- **/var**：存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志）等；
- /proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；
- /sbin: 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；
- /mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；
- /boot： 存放用于系统引导时使用的各种文件；
- /lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。

---

**文件存储结构** [参考](https://blog.csdn.net/xiaoyi23000/article/details/51345179?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=1331303.8433.16182822783820341&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control) [参考](https://blog.csdn.net/github_37882837/article/details/90672881)

<img src="https://img-blog.csdnimg.cn/20190529160046882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zNzg4MjgzNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" />

- 目录项：存储文件名和inode节点号。
- **Inode / 索引结点**：存储文件元信息（文件创建者、创建日期、大小等）和数据块指针
- 数据块：存储文件的具体数据

**mv的话 inode数会+1么** [参考](https://www.cnblogs.com/yuxiuyan/p/13598363.html)

不会，仅会改变目录项中存储文件名和inode节点号的映射，其余的inode和数据块不变

**硬链接和软链接的区别**⭐ [参考](https://www.cnblogs.com/songgj/p/9115954.html) [参考](https://blog.csdn.net/gao_zhennan/article/details/79127232)

<img src="https://img-blog.csdn.net/20160508143008550?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom: 80%;" />

- 硬链接是一个指向inode的指针，每添加一个硬链接文件的链接数就加 1 ；软链接/符号链接是一个普通文件，内容为源文件的路径，类似于windows中的快捷方式。
- 硬链接指向一个 inode 节点；软链接则是创建一个新的 inode 节点
- 硬链接不能用于目录，只能对文件创建；软链接可以用于目录
- 硬链接不可跨文件系统；软连接可以跨文件系统
- 删除源文件硬链接不受影响；软链接则不可用

**文件描述符fd**⭐ [参考](https://www.itqiankun.com/article/file-fd)

- 系统为了维护文件描述符建立了3个表：进程文件描述符表、系统文件描述符表、系统inode表
- 文件描述符是一个指向进程文件描述符表的索引（非负整数）。进程打开/新建一个文件时，内核会返回一个文件描述符用于标明文件
- 进程通过文件描述符获得进程文件描述符表的文件指针，然后通过文件指针获得系统文件描述符表的文件偏移量，再通过文件偏移量获得系统inode表的inode指针，最终通过inode指针获得对应到真实的文件

​                                                        <img src="https://itqiankun.oss-cn-beijing.aliyuncs.com/picture/blogArticles/2020-04-11/1586592325.png" alt="file-fd" style="zoom:67%;" />

> linux中是没有文件句柄的，只有文件描述符，只是大家习惯把它说成句柄。
>
> 文件描述符表索引值从0开始，所以在不同的进程中可以看到相同的文件描述符。

#### IO⭐ 

**五种IO模型**  [参考](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect) [参考](https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA)

java 提供了同步阻塞IO（BIO）、同步非阻塞IO（NIO）和异步IO（AIO），本质上依赖操作系统层面的IO操作

两阶段：数据准备+数据拷贝

**1 阻塞IO**

询问内核是否将数据准备好，若未准备好，则一直等待

<img src="https://img-blog.csdnimg.cn/20201017135503481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llemhhemhhbmcxNzcy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom: 67%;" />

**2 非阻塞IO**

询问内核是否将数据准备好，若未准备好，则直接返回，然后对内核进行轮询

<img src="https://img-blog.csdnimg.cn/20201017135913919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llemhhemhhbmcxNzcy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom: 67%;" />

**3 信号驱动IO模型**

通知内核某个（文件描述符）事件发生时，向其发送信号

<img src="https://img-blog.csdnimg.cn/20201017140257863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llemhhemhhbmcxNzcy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:67%;" />

**4 IO多路复用模型**

多个进程的IO注册到同一管道上，由管道和内核进行交互。

<img src="https://img-blog.csdnimg.cn/20201017140453531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llemhhemhhbmcxNzcy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:67%;" />

以上**四种IO过程都是同步的**，因为无论数据准备是否异步，数据拷贝操作是同步的。

**5 异步IO模型**

完全由内核去拷贝文件。内核完成相关操作后，会发送信号通知进程本次IO已经完成。

<img src="https://img-blog.csdnimg.cn/20201017140904700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llemhhemhhbmcxNzcy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom: 67%;" />

---

**三个IO多路复用函数 / select、poll、epoll的区别** [参考](https://www.jianshu.com/p/397449cadc9a) [参考](https://leehao.blog.csdn.net/article/details/67631516?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&dist_request_id=1328741.49513.16170766321968799&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control)

I/O多路复用实际上就是用select、poll、epoll监听多个IO对象，当IO对象有变化时就通知用户进程。

好处：单个进程可以处理多个socket，大大的降低等待事件就绪的时间，从而有效的提高IO效率。

**1 select**⭐

- 使用long类型的`fd_set`数组管理文件描述符
- 调用select()时，内核会遍历并根据IO状态修改数组元素，由此通知进程哪一文件/socket可读

**优点**

可以在一个线程内同时处理多个socket的IO请求。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。

**缺点**

- 每次调用select是都需要把`fd_set`数组从用户态拷贝到内核态并进行遍历，数组大时开销很大
- 为此，内核对被监控的`fd_set`集合做了大小限制，通过宏控制为1024，大小不可改变

**2 poll**

- 使用`pollfd`链表替代`fd_set`数组，大小无限制
- 其他机制与select没有多大差别

**优缺点**

只改正了大小无限制的缺点，其他跟select基本一样

**3 epoll**⭐

- 使用红黑树管理文件描述符，文件描述符无上限且只用拷贝一次（调用`epoll_ctl`注册文件描述符）
- 基于事件驱动的IO方式，文件描述符就绪时，会使用**回调**方法将该文件描述符放入到就绪队列中
- 调用`epoll_wait`可以直接从就绪队列中获取就绪的文件描述符，内核无需轮询，时间复杂度是O(1)

**水平触发和边缘触发的区别**⭐

epoll除了提供select/poll那种IO事件的水平触发外，还提供了边缘触发。这就使得用户空间程序有可能缓存IO状态，减少epoll_wait（等待事件的就绪）的调用，提高应用程序效率。

- **水平触发LT**（默认）：一直通知直到就绪事件处理完成为止。epoll_wait检测到文件描述符事件就绪并通知时，可以不立即处理。因为下次调用epoll_wait时，会再次通知此事件。
- **边缘触发ET**： 只通知一次。epoll_wait检测到文件描述符事件就绪并通知时，必须立即处理，性能好。因为下次调用epoll_wait时，不会再次通知此事件。

|            |                       select                       |                       poll                       |                            epoll                             |
| :--------- | :------------------------------------------------: | :----------------------------------------------: | :----------------------------------------------------------: |
| 底层实现   |                        数组                        |                       链表                       |                            红黑树                            |
| fd拷贝     | 每次调用select，都需要把fd集合从用户态拷贝到内核态 | 每次调用poll，都需要把fd集合从用户态拷贝到内核态 | 调用epoll_ctl把fd集合从用户态拷贝进内核态后，使用红黑树进行管理。之后无需拷贝 |
| 操作方式   |                        遍历                        |                       遍历                       |                             回调                             |
| IO效率     |      每次调用都进行线性遍历，时间复杂度为O(n)      |     每次调用都进行线性遍历，时间复杂度为O(n)     | 事件通知方式。fd就绪时回调函数会被调用，将就绪fd放到就绪队列中，时间复杂度O(1) |
| 最大连接数 |              1024（x86）或2048（x64）              |                      无上限                      |                            无上限                            |

---

**零拷贝** [参考](https://www.jianshu.com/p/581dc748db78) [参考](https://baijiahao.baidu.com/s?id=1664128784220450138&wfr=spider&for=pc) [参考](https://www.jianshu.com/p/fad3339e3448)

**详细描述一次IO过程 / Java IO读取文件的底层过程**⭐

一次完整IO操作，是文件从硬盘中拷贝到用户空间的过程，涉及用户态与内核态的切换

- 数据准备：文件描述符事件就绪时，我们才可以对其进行IO操作 
- 数据拷贝：数据先从磁盘复制到内核缓冲区，再复制到用户空间

<img src="https://upload-images.jianshu.io/upload_images/272719-9b800f62a9c0e47d.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/544/format/webp" alt="img" style="zoom:50%;" />

**什么是零拷贝技术**⭐

零拷贝技术是指避免用户态(User-space) 与 内核态(Kernel-space) 之间来回拷贝数据。

传统IO模型：

- 将文件通过 DMA 技术从磁盘中拷贝到内核缓冲区
- 将文件从内核缓冲区拷贝到用户空间缓存
- 将文件从用户空间缓存拷贝到 socket 缓冲区中
- 将socket缓冲区中的文件通过 DMA 技术拷贝到网卡

<img src="https://upload-images.jianshu.io/upload_images/272719-9b800f62a9c0e47d.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/544/format/webp" alt="img" style="zoom:50%;" />

**讲一下DMA的作用**

DMA (Direct Memory Access，直接存储器访问) ：允许不同速度的硬件进行沟通，而不需要 CPU 大量的中断负载。否则CPU 需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方，处于不可用的状态。

原理：将数据从一个地址空间复制到另外一个地址空间

**1 mmap (NIO的MappedByteBuffer Rocketmq)**

使用mmap()代替read调用

- 应用程序调用`mmap()`，磁盘上的数据会通过`DMA`拷贝到内核缓冲区
- 操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝
- 应用程序再调用`write()`,操作系统直接将内核缓冲区的内容拷贝到`socket`缓冲区中
- `socket`缓冲区再把数据发到网卡去。

<img src="https://upload-images.jianshu.io/upload_images/272719-c955c60095647d6e.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/550/format/webp" alt="img" style="zoom:50%;" />

> mmap存在的问题？

**2 sendfile (kafka)** 

linux 2.1，Linux引入了`sendfile`来简化操作：

- 系统调用`sendfile()`在代表输入文件的描述符`in_fd`和代表输出文件的描述符`out_fd`之间传送文件内容（字节）。
- 描述符`out_fd`必须指向一个套接字，而`in_fd`指向的文件必须是`mmap`的。这些局限限制了`sendfile`的使用，使`sendfile`只能将数据从文件传递到套接字上，反之则不行。

<img src="https://upload-images.jianshu.io/upload_images/272719-5c49aebc85085726.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/626/format/webp" alt="img" style="zoom:50%;" />

linux 2.4，`sendfile`进一步优化，避免了最后一次拷贝：

- `sendfile`系统调用利用`DMA`引擎将文件内容拷贝到内核缓冲区去
- 将带有文件位置和长度信息的缓冲区描述符添加socket缓冲区去，这一步不会将内核中的数据拷贝到socket缓冲区中
- `DMA`引擎会将内核缓冲区的数据拷贝到协议引擎中去

> Kafka 的索引文件使用的是 mmap + write 方式，数据文件使用的是 sendfile 方式。

<img src="https://upload-images.jianshu.io/upload_images/272719-8461cc4141c8dd45.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/833/format/webp" alt="img" style="zoom:50%;" />

> **3 splice**
>
> sendfile只适用于将数据从文件拷贝到套接字上，限定了它的使用范围。
>
> Linux在`2.6.17`版本引入`splice`系统调用，用于在两个文件描述符中移动数据……