### JVM概述

#### JVM基础

**什么是 JVM？JVM 的主要组成部分及其作用？**

JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。

JVM 能跨计算机体系结构来执行 Java 字节码，屏蔽了各个计算机平台的软件或者硬件的差异，使得与平台相关的耦合统一由 JVM 实现。

<img src="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 50%;" />

**组成**

- 两个子系统
  - Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到运行时数据区域中的方法区
  - Execution engine（执行引擎）：执行类中的指令
- 两个组件
  - Native Interface(本地接口)：与本地方法库交互，是其它编程语言交互的接口。
  - Runtime data area(运行时数据区域)：常说的JVM的内存。

**作用**

- 首先通过**编译器**把 Java 代码转换成字节码
- **类加载器**（ClassLoader）再把字节码加载到内存中，将其放在**运行时数据区**的方法区内
- 而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令**解析器执行引擎**（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行
- 而这个过程中需要调用其他语言的**本地库接口**（Native Interface）来实现整个程序的功能。

**Jvm结束生命周期**

- 执行了 System.exit()方法
- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止

#### 平台无关

**Java 是如何实现跨平台的？/ 如何理解JAVA中的一次编译处处运行？**

跨平台性指java编写的程序，一次编译，可以在多个系统平台上运行。（注意**：跨平台的是 Java 程序，而不是 JVM。**JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM）

- Java 源码，编译后会生成一种 .class 文件，称为**字节码文件**。JVM负责将字节码文件翻译成特定平台下的**机器码**，然后运行Java 程序

> Java源代码---->编译器---->jvm的可执行字节码---->jvm中解释器（类加载等）----->机器可执行的二进制机器码---->程序运行

- 这个过程 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/M7B64fHXISsbRGDZNELDP3VibTMCmbN57ib5iaVicFpibadricV9fCpO2yFUbMrGn4ahN4XyNaM5g0rSxKgZtcuoJRJA/640?wx_fmt=png)

**什么是字节码？采用字节码的最大好处是什么**

字节码：Java程序经过虚拟机编译器编译后产生的文件（.class的文件），不面向任何特定的处理器，只面向虚拟机。

采用字节码的好处：一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效；而且字节码并不专对一种特定的机器，因此Java程序无须重新编译便可在多种不同的计算机上运行。

### 内存区域与内存溢出 2

#### 运行时数据区域⭐

**说一下 JVM 运行时数据区**

<img src="https://img-blog.csdnimg.cn/20200103213220764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 33%;" />

- 程序计数器（Program Counter Register）

  - 当前线程的**字节码行号指示器**，通过改变计数器的值来选取下一条需要执行的字节码指令。
  - 分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；
  - > 唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。
- 虚拟机栈（Java Virtual Machine Stacks）
  - **Java方法执行的内存模型**
  - 每个方法在执行时都会创建一个**栈帧**来存储**局部变量、操作数、动态链接、方法出口**等信息
  - 每个方法调用意味着一个栈帧在虚拟机栈中从入栈到出栈的过程；
- 本地方法栈（Native Method Stack）
  - 和Java虚拟机栈的作用类似
  - 区别是该区域提供的是**native 方法**的服务
- 堆（Java Heap）
  - Java 虚拟机中内存最大的一块，被所有线程共享，存储几乎所有的**对象实例**
  - 垃圾收集器管理的主要区域。目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；
- 方法区（Methed Area）
  - 存储虚拟机加载的**类信息、常量、静态变量**、即时编译器编译后的代码等数据。
  - > 虽然 Java 虚拟机规范描述为堆的一个逻辑部分，但是它却又一个别名 Non-Heap（非堆），目的应该是与 Java 堆区分开来

**哪些区域是线程不安全的**

堆、方法区（线程共享）

---

**堆栈**

**说一下堆和栈的区别**⭐

- 存放内容
  
  - 堆存放的是对象实例。该区更关注的是数据的存储
  - 栈存放的是局部变量、操作数、动态链接、方法出口。该区更关注的是方法的执行。
- 物理地址
  - 堆的物理地址不连续，因此性能较慢。
  - 栈的物理地址连续，因此性能较快。
- 内存大小
  - 堆是不连续的链表，所以分配的内存是在**运行期**确认，大小不固定。一般堆远远大于栈。
  - 栈是连续的数组，所以分配的内存要在**编译期**确认，大小固定。
- 可见度

  - 堆对于整个程序都是共享、可见的。
  - 栈只对于线程可见，生命周期和线程相同。

**下面涉及的变量和对象分别在哪些空间**

```java
static int g = 12;   			//g静态变量：方法区
int add(int a,int b){   		//add方法、a b参数局部变量：虚拟机栈   
    int c = a + b;   			//c局部变量：虚拟机栈
    String str = new String();  //String对象：堆
    return c;   
}   
```

---

**方法区**

**jdk1.8方法区的实现由永久代变成了元空间**

永久代

- 永久代是hotspot虚拟机特有的概念，**在虚拟机中**。
- 在触发full gc的情况下会进行垃圾回收，消耗性能。

元空间

- 元空间是metaspace，与永久代最大的区别在于使用**本地内存**，不在虚拟机中。
- jdk1.8移除了永久代的概念。将元数据剥离出来，简化了垃圾收集，提高了效率。

---

**常量池介绍** [参考](https://blog.csdn.net/qq_26222859/article/details/73135660?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)

- 运行时常量池：方法区的一部分，用于存放编译器生成的各种**字面量和符号引用**。

- 字符串常量池 [参考](https://www.cnblogs.com/talkingcat/p/13341967.html)

  字符串常量池位于**堆**内存（jdk6之前在方法区，jdk7开始在堆）中，专门用来存储字符串常量。

  在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。可提高内存的使用率，避免开辟多块空间存储相同的字符串（**String.intern()方法**）

#### HotSpot虚拟机对象⭐

**对象的内存布局**

- **对象头**

  - **对象标记Mark Word**：存储对象自身的运行时数据，如哈希码、分代年龄等，32个或64个bits（根据虚拟机位数）

    Mark Word 被设计为动态数据结构，以便在极小的空间存储更多数据，根据对象状态复用存储空间。

  - **类型指针**：对象指向它的类型元数据的指针，占 4B，JVM 通过该指针来确定对象是哪个类的实例。

- 实例数据：对象真正存储的有效信息，即本类对象的实例成员变量和所有可见的父类成员变量。存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响。

- 对齐填充：仅起占位符作用。虚拟机的内存管理系统要求任何对象的大小必须是 64位 的倍数，如果没有对齐需要对齐填充补全。

**Java对象头前32位标识的含义**

在32位的HotSpot虚拟机中无锁态下

- 25Bits用于存储哈希码（HashCode）
- 4Bits用于存储分代年龄
- 1Bit用于表示是否为偏向锁，固定为0
- 2Bits用于存储锁标志位

<img src="https://img-blog.csdn.net/20151217151455512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom: 67%;" />

**有了解过字节对齐吗**

实例：Jvm中的对齐填充

---

**Java中提供的几种对象创建方式**

| Header                         | 解释             |
| ------------------------------ | ---------------- |
| new关键字                      | 调用了构造函数   |
| Class的newInstance方法         | 调用了构造函数   |
| Constructor类的newInstance方法 | 调用了构造函数   |
| clone方法                      | 没有调用构造函数 |
| 反序列化                       | 没有调用构造函数 |

**创建对象的过程 / java new一个object的过程**⭐

Java中对象的创建就是在**堆**上分配内存空间的过程，此处说的对象创建**仅限于new关键字创建的普通Java对象**，不包括数组对象的创建。

**1 检测类是否被加载**

先去常量池中查找这个类的符号引用。

- 如果能找到符号引用，说明此类已经被加载到方法区，可以继续执行；
- 如果找不到符号引用，就会使用类加载器执行**类的加载过程**，类加载完成后继续执行。

**2 为对象分配内存**

类加载完成以后所需内存的大小就确定了。进而在堆上分配内存

- 内存绝对规整：虚拟机只需要在被占用内存和可用空间之间移动指针即可，这种方式被称为**指针碰撞**。
- 内存不规整：虚拟机需要维护一个列表来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为**空闲列表**

> 也需要考虑**线程安全问题**
>
> - 同步：使用CAS来保证操作的原子性。
> - 每个线程在自己的空间内分配内存：程在堆中预先分配一小块内存，称为**本地线程分配缓冲（TLAB）**，分配内存时在TLAB上分配，互不干扰。
>

**3 为分配的内存初始化零值**

保证对象即使没有赋初值，也可以直接使用。

**4 进行其他设置**

在**对象头**中，包括这个对象的hashcode、GC分代年龄等。

**5 执行 init 方法**

- 执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了
- 但是对Java程序来说还需要执行init方法，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了init方法之后，这个对象才真正能使用。

---

**对象的访问定位**

`Java`程序需要通过 `JVM` 栈上的引用访问堆中的具体对象。 

> **指针：** 指向对象，代表一个对象在内存中的**起始地址**。
>
> **句柄：** 可以理解为**指向指针的指针**，维护指向对象的指针变化，而对象的句柄本身不发生变化？

**句柄访问**

堆中划分出一块内存来作为**句柄池**，引用存储对象的句柄地址，而句柄中包含对象实例数据与对象类型数据的地址

<img src="https://img-blog.csdn.net/20160505130804767" alt="句柄访问对象" style="zoom: 33%;" />

优势：引用中存储的是稳定的句柄地址，对象被移动（垃圾收集）只改变句柄中的实例数据指针，而引用本身不需要修改

**直接指针**

引用中存储的直接就是**对象地址**

<img src="https://img-blog.csdn.net/20160505130823283" alt="直接内存访问对象" style="zoom: 33%;" />

优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在`Java`中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。

#### 内存溢出OOM⭐

**内存泄漏和内存溢出**⭐

- 内存溢出 OutOfMemory，指程序在申请内存时，**没有足够的内存空间**供其使用。
- 内存泄露 Memory Leak，指程序在申请内存后，**无法回收**已申请的内存空间。
- 内存泄露是导致内存溢出的原因之一：内存泄露积累起来将导致内存溢出。

**内存泄漏的原因分析**

- 长生命周期对象引用短生命周期的对象。因为长生命周期对象持有它的引用而导致不能被回收
- 没有将无用对象置为null

---

**什么时候会发生OOM（写代码？），怎么解决**⭐ [参考](https://www.cnblogs.com/ilovejaney/p/13685788.html) [参考](https://blog.csdn.net/hounanjsj/article/details/54612444)

**1 栈溢出**

- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常
- 如果虚拟机栈可以动态扩展，并且扩展时无法申请到足够的内存，抛出OutOfMemoryError异常

```java
public class StackOOM {
    private int length = 1;

    public void stackTest() {
        System.out.println("stack lenght=" + length);
        length++;
        stackTest();
    }

    public static void main(String[] args) {
        StackOOM test = new StackOOM();
        test.stackTest();
    }
}
```

第一个情况：一般来说是不会出现的，出现的话应该是代码问题，检查代码如dfs

第二个情况：减少线程数量；若不能减少线程数量，那么考虑“减少内存”，即通过减少堆和减少栈容量来换取更多的线程

**2 堆溢出**

不停的创建对象，并且保证GC Roots和对象之间有可达路径避免垃圾回收

```java
public class HeapOOM {
    public static void main(String[] args) {
        List<HeapOOM> list = new ArrayList<>();
        while (true) {
            list.add(new HeapOOM());
        }
    }
}
```

如果是内存泄露，要使用工具查看泄露对象到GC Roots的引用链，找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们。

如果不是内存泄露，那么就要检查JVM参数（-Xmx与-Xms），根据机器物理内存情况看看是否能把参数调大一些；另一方面，从代码层面考虑，看看是否存在某些对象生命周期过长的情况，优化代码，减少程序在运行期的内存消耗。

**3 方法区（运行时常量池）溢出**

方法区包含类信息、常量、静态变量。可以不断往其中加入常量

```java
private static String str = "test";
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        while (true){
            String str2 = str + str;
            str = str2;
            list.add(str.intern());
        }
}
```

---

**如何排查一下线上OOM问题？**⭐[参考](https://zhuanlan.zhihu.com/p/165981061) [参考](https://zhuanlan.zhihu.com/p/126750819)

dump文件文件记录了JVM运行期间的内存占用、线程执行等情况

- `-XX:+HeapDumpOnOutOfMemoryError` 参数可以在发生 OOM 时自动进行 dump；
- `jmap` 命令可以手动 dump；
- 可以使用 JDK 自带的工具 jvisualvm.exe 进行分析。

**你都有哪些手段用来排查内存溢出？**

没实操过，网上看的

（这个话题很大，可以从实践环节中随便摘一个进行总结，下面举例一个最普通的）你可以来一个中规中矩的回答：

- 内存溢出包含很多种情况，我在平常工作中遇到最多的就是`堆溢出`。
- 有一次线上遇到故障，重新启动后，使用jstat命令，发现Old区在一直增长。
- 我使用jmap命令，导出了一份线上堆栈，然后使用`MAT`进行分析。
- 通过对`GC Roots`的分析，我发现了一个非常大的HashMap对象，这个原本是有位同学`做缓存`用的，但是一个无界缓存，造成了堆内存占用一直上升。
- 后来，将这个缓存改成 guava的Cache，并设置了弱引用，故障就消失了。

### 垃圾回收与内存分配  3

#### 对象判定存活算法⭐

在JVM中，有一个低优先级的垃圾回收线程，只有在虚拟机空闲或者当前堆内存不足时才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

**怎么判断对象是否可以被回收？**

- 引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。不使用它的原因是其**循环引用**的缺点（A B相互引用）；
- 可达性分析法：从 GC Roots 开始向下搜索，走过的路径称为**引用链**。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。

**什么是GC Roots**

- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中静态变量、常量引用的对象

**finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？**

- 除可达性分析外，GC还要二次判断，垃圾回收器会调用对象的finalize()方法，只要对象重新与引用链相连，就会被移出回收集合
- 若对象没有重写ﬁnalize()方法或ﬁnalize()方法已经被调用过，则是真正的"死"对象，在**下一次垃圾回收时**回收

> 大部分情况什么都不做。只有在某些很特殊的情况下，如调用了一些native方法，可以在finaliztion里去调用C语言的释放函数

**如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？**

不会，而是在下一次垃圾回收时才回收。finalize()……

**Stop The World、safepoint、OopMap** 

当虚拟机完成两次标记后才能确认可回收的对象。GC是与当前程序并发执行的，若GC线程第一次标记好对象后，程序线程又将该对象重新加入了“关系网”中，二次标记时该对象也没有重写finalize()方法，这时就会回收掉这个不该回收的对象。 

解决方法是在一些特定指令位置设置一些**安全点**，当程序运行到这些安全点时，暂停除了GC线程之外的所有线程（**Stop The World** STW），再次对“GC Roots”进行关系的组建。安全点主要在：循环的末尾；方法临返回前 / 调用方法的call指令后；可能抛异常的位置

找到“GC Roots”要花很长的时间，可以通过采用一个**OopMap**（准确式GC）的数据结构来记录系统中存活的“GC Roots”。

> **类加载完成时**，虚拟机就把对象内什么偏移量上是什么类型的数据计算出来保存在OopMap，以便后序快速找到GC Roots。

**Java 中都有哪些引用类型？**⭐ [参考](https://www.cnblogs.com/fengbs/p/7019687.html)

- **强引用**：gc 时不会回收。用于创建对象等。Object obj = new Object()"
- 软引用：内存不足时回收。用于实现内存敏感的高速缓存。SoftReference
- **弱引用**：gc 时回收。用于ThreadLocal。WeakReference
- 虚引用：任何时候都可回收。用于jvm回收堆外内存

![img](https://images2015.cnblogs.com/blog/647994/201702/647994-20170215235519441-1287012986.png)

#### GC算法⭐

**GC算法有哪些**⭐

**1 分代收集理论**

根据对象存活周期将堆内存划分为几块，一般是新生代和老年代

- 新生代
  - 年轻代存放新近创建的对象，存在的对象死亡非常快，存在朝生夕死的情况。
  - 新生代默认占比 1/3
  - 新生代基本采用标记-复制算法
- 老年代

  - 老年代中存放存活很久，年龄大于15的对象。
  - 老生代的默认占比 2/3    
  - 老年代采用标记-整理算法

**2 标记-清除算法**

标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。

分为两个阶段：

- 标记阶段：标记出可以回收的对象。
- 清除阶段：回收被标记的对象。

优点：实现简单，不需要对象进行移动。

缺点：标记、清除过程效率低；产生大量不连续的**内存碎片**，导致大对象需要分配内存时，大内存少，垃圾回收的频率高。

<img src="https://img-blog.csdnimg.cn/20200104115917418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

**3 标记-复制算法（新生代Minor GC）**

**半区复制**

- 把内存划为两个相等的区域，每次只使用其中一个区域。
- 垃圾收集时遍历当前使用区域，把存活对象复制到另外一个区域中
- 将当前使用区域的可回收的对象进行回收。

优点：内存分配时只需要移动堆顶指针，按顺序分配内存即可，实现简单、运行高效；不用考虑内存碎片。

缺点：可用的内存大小缩小为原来的一半；对象存活率高时会频繁进行复制。

<img src="https://img-blog.csdnimg.cn/20200104115940771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

**Appel式回收**

现在的商用虚拟机(包括HotSpot)都是采用这种收集算法来回收新生代。

- 因为新生代中98%的对象都是"朝生夕死"的，所以并不需要按照1 : 1的比例来划分新生代内存空间。而是将新生代内存空间按8:1:1分为一块较大的Eden(伊甸园)空间和两块较小的Survivor(幸存者)空间。两个Survivor区域一个称为From区，另一个称为To区。

- Eden区满时会触发第一次gc，把存活对象拷贝到From区

  Eden区再次触发gc时，会扫描Eden区和From区进行垃圾回收，存活的对象直接复制到To区，并将Eden区和From区清空。

  Eden区又发生gc的时，会扫描Eden区和To区进行垃圾回收，存活的对象复制到From区，并将Eden区和To区清空

  Survivor空间不够用时，需要依赖老年代进行**分配担保**。

- 如此交换15次(由参数**MaxTenuringThreshold年龄**决定，默认是15)，对象如果还存活，就存入老年代。
  <img src="https://img-blog.csdn.net/20180626164124931?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1YnVqaWFuX2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom: 67%;" />

**4 标记-整理算法（老年代Major GC）**

- 老年代不能选择复制算法，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。


- 在标记可回收的对象后将所有存活的对象压缩到内存的一端
- 对端边界以外的内存进行回收

优点：解决了标记-清除算法存在的内存碎片问题。

缺点：仍需要进行局部对象移动，一定程度上降低了效率。

<img src="https://img-blog.csdnimg.cn/20200104120006513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

---

**GC是什么？为什么要GC**

GC 是垃圾收集的意思（Gabage Collection）

有了GC，Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。

**介绍下Java的垃圾收集机制**

对象判定存活算法 + GC算法

**还有了解其他GC算法吗**

增量算法。主要思想是GC线程与用户线程交替执行，一边执行垃圾回收一边执行用户代码。但是会造成系统吞吐量下降。

**JVM中的永久代中会发生垃圾回收吗** [参考](https://blog.csdn.net/qq_42147250/article/details/107099388) 

会发生Full GC，需要同时满足以下三个条件

- 该类的所有**实例**都已经被回收，堆中不存在该类及其任何子类的实例。
- 该类的**类加载器**已经被回收，这个条件通常是很难达到的。
- 该类对应的**java.lang.Class对象**没有被引用，无法在任何地方通过反射访问该类的方法。

但不是像对象那样必然回收，可通过参数加以控制

---

**Minor GC、Major GC和Full GC之间的区别**

- Minor GC ：回收新生代中的Eden区（Survivor区满时不会触发）
- Major GC ：回收老年代 ，目前**只有CMS收集器**老年代满时会触发 Major GC
- Full GC ：清理整个堆和方法区。Full GC的耗时是Minor GC的十倍左右，频率相对小很多 

**对象如何进入老年代**⭐

- GC年龄判定：每进行一次GC，存活对象的GC年龄都会+1，年龄达到15岁时即可进入老年代。通过-XX:MaxTenuringThreshld设置

- 动态年龄判定：有的垃圾回收器如G1并不要求age必须达到15才能晋升到老年代。Survivor空间中某一年龄的对象大小总和大于Survivor空间的一半时，年龄大于等于该年龄的对象就可以直接进入老年代

- 大对象直接进入老年代：当创建对象的大小大于设置大小时，直接进入老年代；通过-XX:PretenureSizeThreshold设置

- 老年代分配担保：Survivor 空间不够时，依赖老年代进行分配担保，对象直接在老年代上分配。

**老年代分配担保**

在发生minor gc之前，虚拟机会检测老年代最大连续可用空间是否大于新生代所有对象空间

- 大于，minor gc安全，可进行minor gc
- 不大于，虚拟机查看HandlePromotionFailure参数：
  - 为true，允许冒险，检测老年代最大连续可用空间是否大于历次晋升到老年代的平均对象大小
    - 大于，尝试进行minor gc
    - 小于，重新进行full gc
  - 为false，则不允许冒险，进行full gc

**简述java内存分配与回收策略**

- GC年龄判定
- 动态年龄判定

- 大对象直接进入老年代

- 老年代分配担保
- 对象优先在 Eden 区分配：多数情况下对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。

**Full GC的时机**⭐[参考](https://blog.csdn.net/a55684471/article/details/102366421) 

- 老年代空间不足

- 老年代分配担保失败：……

- 大对象直接进入老年代且老年代空间不足

- 方法区空间不足

- 调用System.gc()时。系统建议执行Full GC，但是不一定会执行。

- > 执行jmap -histo:live或jmap -dump:live：强制虚拟机执行full GC

#### 垃圾回收器⭐

如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。不同收集器之间的连线表示它们可以搭配使用。

<img src="https://img-blog.csdnimg.cn/20200104120144820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" />

- Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；
- ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程 版本，在多核CPU环境下有着比Serial更好的表现；
- Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；
- **Serial Old**收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；
- Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；
- **CMS**(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，**以获取最短回收停顿时间为目标**，具有高并发、低停顿的特点。
- **G1**(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：**G1回收的范围是整个Java堆**(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。

**垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？**

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。

通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。（判断存活算法）

可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

**新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？**

- 新生代回收器：Serial、ParNew、Parallel Scavenge
- 老年代回收器：Serial Old、Parallel Old、CMS
- 整堆回收器：G1

新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。

**详细介绍一下 CMS 垃圾回收器？**⭐ [参考](https://www.cnblogs.com/heyonggang/p/11718170.html)

CMS(Concurrent Mark Sweep)是老年代并行收集器，使用**标记-清除**的算法。

以牺牲吞吐量为代价获得**最短回收停顿时间**，具有高并发、低停顿的特点。

> gc 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器(标记-整理算法)进行垃圾清除，此时的性能将会被降低。

过程

- 初始标记：标记 GC Roots 能直接关联的对象，速度很快。

- **并发标记**：从 GC Roots 直接关联对象开始遍历整个对象图，耗时较长但可与用户线程并发。

- 重新标记：修正并发标记期间因用户程序执行而导致的标记变动记录。

- **并发清除**：清理标记阶段判断的死亡对象，也可与用户线程并发。

优点：并发收集、低停顿，最耗时的并发标记和并发清除过程都可以与用户线程并发。

缺点

- 对处理器资源敏感，并发阶段虽然不会导致用户线程暂停，但会降低吞吐量。
- 无法处理浮动垃圾，有可能出现并发失败而导致 Full GC。
- 基于清除算法，会产生空间碎片。

**详细介绍一下G1垃圾回收器？**⭐

G1(Garbage First)是堆并行收集器，使用**标记-整理**算法。

开创了**面向局部回收的设计思路**和**基于 Region 的内存布局**。不同于之前的收集器，可面向堆任何部分来组成回收集进行回收。衡量标准不再是分代，而是哪块内存中垃圾的价值最大。价值即回收所获空间大小以及以往回收所需时间的经验值，G1 在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值最大的 Region。



<img src="https://img-blog.csdnimg.cn/20190829095740435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h5ZzA4MTE=,size_16,color_FFFFFF,t_70" alt="G1堆的Region布局.png" style="zoom:33%;" />

过程

- 初始标记：标记 GC Roots 能直接关联到的对象，让下一阶段用户线程并发运行时能正确地在可用 Region 中分配新对象。需要 STW 但耗时很短，在 Minor GC 时同步完成。
- **并发标记**：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆的对象图。耗时长但可与用户线程并发。描完成后要重新处理 SATB 记录的在并发时有变动的对象。
- 最终标记：对用户线程做短暂暂停，处理并发阶段结束后仍遗留下来的少量 SATB 记录。
- 筛选回收：对各 Region 的回收价值排序，根据用户期望停顿时间制定回收计划。必须暂停用户线程，由多条收集线程并行完成。

优点

- 并行并发。G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。
- 分代收集。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果。
- 空间整合。G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
- 可预测的停顿。降低停顿时间是G1和CMS共同的关注点，但G1还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。

缺点：无论内存占用还是程序运行时的额外执行负载都要比CMS高

**ZGC**

JDK11 中加入的具有实验性质的低延迟垃圾收集器，目标是尽可能在不影响吞吐量的前提下，实现在任意堆内存大小都可以把停顿时间限制在 10ms 以内的低延迟。

基于 Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记整理。ZGC 的 Region 具有动态性，是动态创建和销毁的，并且容量大小也是动态变化的。

### JVM调优 4

#### 故障处理工具⭐

**基础故障处理工具**

- jps：虚拟机进程状况工具。列出正在运行的虚拟机进程，使用 Windows 的任务管理器或 UNIX 的 ps 命令也可以查询，但如果同时启动多个进程，必须依赖 jps。
- jinfo：Java 配置信息工具。查看虚拟机各项参数，使用 `jps -v` 可查看虚拟机启动时显式指定的参数，但如果想知道未显式指定的参数只能使用 `jinfo -flag`。
- jhat：虚拟机堆转储快照分析工具。JDK 提供 jhat 与 jmap 搭配使用分析堆转储快照。jhat 内置微型的 HTTP/Web 服务器，堆转储快照的分析结果后可以在浏览器查看。
- **jstat**：**虚拟机**监视工具。监视虚拟机各种运行状态信息，显示本地或远程虚拟机进程中的类加载、内存、垃圾收集、即时编译器等运行时数据。
- **jmap**：Java **内存映像**工具。用于生成堆转储快照，还可以查询 finalize 执行队列、Java 堆和方法区的详细信息，如空间使用率，当前使用的是哪种收集器等。jmap pid
- **jstack**：Java **线程堆栈**工具。用于生成虚拟机当前时刻的线程快照，定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。 jstack pid | grep 16位线程号 （CPU排查等）

**可视化故障处理工具**

JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。

- **jconsole**：用于对 JVM 中的内存、线程和类等进行监控；
- **jvisualvm**：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。

#### 调优参数与调优⭐

**调优参数**

| 参数                           | 说明                                                         |
| :----------------------------- | :----------------------------------------------------------- |
| **-Xms**                       | 初始堆大小，默认物理内存的1/64                               |
| **-Xmx**                       | 最大堆大小，默认物理内存的1/4                                |
| **-Xmn**                       | 新生代内存大小，官方推荐为整个堆的3/8                        |
| **-XX:NewRatio=n**             | 设置新生代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3 |
| **-XX:SurvivorRatio=n**        | 年轻代中Eden区与两个Survivor区的比值。                       |
| **-Xss**                       | 线程堆栈大小，jdk1.5及之后默认1M，之前默认256k               |
| -XX:PermSize=n                 | 永久代初始值，默认为物理内存的1/64                           |
| -XX:MaxPermSize=n              | 永久代最大值，默认为物理内存的1/4                            |
| -verbose:class                 | 在控制台打印类加载信息                                       |
| -verbose:gc                    | 在控制台打印垃圾回收日志                                     |
| -XX:+PrintGC                   | 打印GC日志，内容简单                                         |
| -XX:+PrintGCDetails            | 打印GC日志，内容详细                                         |
| -XX:+PrintGCDateStamps         | 在GC日志中添加时间戳                                         |
| -XX:+PrintFlagsFinal           | 查看JVM系统默认值                                            |
| **-XX:+PrintCommandLineFlags** | 打印所有的参数，包括使用的垃圾回收器。                       |
| -Xloggc:filename               | 指定gc日志路径                                               |
| -XX:+UseSerialGC               | 年轻代设置串行收集器Serial                                   |
| -XX:+UseParallelGC             | 年轻代设置并行收集器Parallel Scavenge                        |
| -XX:ParallelGCThreads=n        | 设置Parallel Scavenge收集时使用的CPU数。并行收集线程数。     |
| -XX:MaxGCPauseMillis=n         | 设置Parallel Scavenge回收的最大时间(毫秒)                    |
| -XX:GCTimeRatio=n              | 设置Parallel Scavenge垃圾回收时间占程序运行时间的百分比。公式为1/(1+n) |
| -XX:+UseParallelOldGC          | 设置老年代为并行收集器ParallelOld收集器                      |
| XX:+UseConcMarkSweepGC         | 设置老年代并发收集器CMS                                      |
| -XX:+CMSIncrementalMode        | 设置CMS收集器为增量模式，适用于单CPU情况。                   |

**类似-Xms、-Xmx、-Xmn这些参数的含义：**

堆内存分配：

1. JVM初始分配的内存由-Xms指定，默认是物理内存的1/64
2. JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4
3. 默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。
4. 因此服务器**一般设置-Xms、-Xmx相等**以避免每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。

非堆内存分配：

1. JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；
2. 由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。
3. -Xmn2G：设置年轻代大小为2G。
4. -XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。）

**调优的三个指标**

- 内存：程序正常运行需要的内存大小。
- 延迟：由于垃圾收集而引起的程序停顿时间。
- 吞吐量：用户程序运行时间占用户程序和垃圾收集占用总时间的比值。

**知道full GC的虚拟机调优吗？**⭐ [参考](https://blog.51cto.com/zero01/2150696#h2)

> 没实操过，网上看的

三个步骤：

- 打印GC日志（使用jvisualvm等工具）
- 分析关键性能指标（如停顿时间、minor Gc full GC次数等）
- 调整JVM参数（大小、扩容速度等）

**调优实例及命令**

[参考](https://segmentfault.com/a/1190000020104437)

### 类加载机制 7

#### 类加载时机⭐

**简述java类加载机制？**

Class 文件中的信息需要加载到虚拟机后才能使用。

类加载机制中虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。

**类加载/初始化时机**

- 遇到new、getStatic、putStatic或invokestatic这4条字节码指令时，类还没有初始化。
- 对类进行反射调用时，类还没有初始化。
- 初始化子类时，父类还未初始化
- 初始化接口的实现类且接口定义了默认方法，接口还未初始化
- 虚拟机启动时，会先初始化包含 main 方法的主类 

#### 类加载过程⭐

**类加载过程 / 类的生命周期**

<img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/M7B64fHXISsbRGDZNELDP3VibTMCmbN57kFUq2loWwrRHGoJ9yeXUOIzU3anw42OL3OIkExg78CR8Yop1yMnAPQ/640?wx_fmt=png" alt="640?wx_fmt=png"  />

类型从被加载到卸出，整个生命周期经历加载、连接、初始化、使用和卸载。连接包括验证、解析和初始化三部分。

> -  加载、验证、准备、初始化的顺序是确定的。Java 类型的加载、连接和初始化都是在运行期间完成的，这增加了性能开销，但提供高扩展性，Java 动态扩展的特性就是依赖运行期动态加载和连接实现的。
> - 解析则不一定：可能在初始化后再开始，这是为了支持 Java 的动态绑定。

**1 加载**

加载阶段是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

- 类加载器通过类的全限定名获取类的二进制字节流。
- 将字节流所代表的静态存储结构转化为**方法区**的运行时数据结构。
- 在**堆**中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。

**2 连接**

**验证：确保被加载类的正确性**

验证阶段是非常重要的，但**不是必须**的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

- 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持	的类型。
- 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。
- 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
- 符号引用验证：确保解析动作能正确执行。

**准备：为类的静态变量分配内存，并初始化为默认值**

准备是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

- 这时候进行内存分配的仅包括类变量（static），而实例变量会在对象实例化时随着对象一块分配在Java堆中。
- 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），Java代码中的显式赋值在初始化阶段完成。


- 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。

**解析：把类中的符号引用转换为直接引用**

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

- 符号引用就是一组符号来描述目标，可以是任何字面量。
- 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

**3 初始化**

初始化为类的静态变量赋予正确的初始值。两种方式：

- 声明类变量是指定初始值
- 使用静态代码块为类变量指定初始值

JVM初始化步骤

- 假如这个类还没有被加载和连接，则程序先加载并连接该类
- 假如该类的直接父类还没有被初始化，则先初始化其直接父类
- 假如类中有初始化语句，则系统依次执行这些初始化语句

**4 使用 **

……

**5 卸载 **[参考](https://www.cnblogs.com/caoxb/p/12735525.html)

Jvm自带的类加载器加载的类是不会卸载的，用户自定义的类加载器加载的类是可以卸载的。

当代表一个类的Class对象不再被**引用**时，Class对象的生命周期就结束了，对应的在方法区中的数据也会被卸载

```java
Object obj = clazz.newInstance();
// 当代表类的Class对象不再被引用时，Class对象就会结束生命周期，类在方法区内的数据也会被卸载
obj = null;
```

#### 类加载器⭐

**什么是类加载器，类加载器有哪些?**⭐

![](https://segmentfault.com/img/remote/1460000008995786?w=894&h=347)

类加载器：能通过类的全限定名获取类的二进制字节流的代码块。

- 启动类加载器(BootstrapClassLoader)：加载 java **核心类库**<JAVA_HOME>/lib。C++实现，无法被java程序直接引用
- 扩展类加载器(ExtClassLoader)：加载 Java **扩展库**<JAVA_HOME>/lib/ext。 Java实现，可以在java里获取
- 系统类/应用程序类加载器(AppClassLoader)：加载 Java **类路径**CLASSPATH。一般来说，Java 应用的类都是由它来完成加载的。
- 用户自定义类加载器(CustomClassLoader)：通过继承 java.lang.ClassLoader类的方式实现。

**Java 虚拟机是如何判定两个 Java 类是相同的？**

Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。

---

**什么是双亲委派模型？**

- 当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类去加载。每一层的都是如此，最后所有的加载请求都会被传送到顶层的启动类加载器
- 如果父类不能加载，则反馈给子类，由子类完成类的加载。

> 双亲委派并不是继承关系，加载一个类时，会在loadClass()方法中**递归**使用parent.loadClass()方法去加载
>
> 双亲委派模型**并非强制模型**

**为什么这样设计呢？**

- 主要是为了安全性：避免用户自己编写的类动态替换 Java 的一些核心类，如 String
- 避免了重复加载：当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。

**有哪些打破了双亲委托机制的案例？**

- Java的**SPI**，如Driver接口
- Tomcat可以加载自己目录下的class文件，而不会传递给父类的加载器。

**为什么需要破坏双亲委派？**⭐ [参考](https://www.zhihu.com/question/49667892) [参考](https://www.cnblogs.com/joemsu/p/9310226.html#_caption_1)

双亲委派模型最大的**局限**在于，假定 A 作为 B 的 parent，A 加载的类对 B 是可见的； 然而 B 加载的类对 A 却是不可见的。受到加载范围的限制，父类加载器可能无法加载到需要的文件，反而需要委托子类加载器去加载class文件，破坏双亲委派。

以SPI的Driver接口为例，DriverManager是由启动类加载器加载，而实现由系统类加载器加载。这时启动类加载器反而要委派系统类加载器加载Driver，从而破坏了双亲委派。

**怎么破坏双亲委派？** [参考](cnblogs.com/joemsu/p/9310226.html#_caption_1)

SPI Serviceloader使用 load 方法通过**线程上下文(ThreadContext)**获取能够加载实现类的classloader（默认AppClassLoader）。绕过了这层限制，逻辑上打破了双亲委派原则。

**如何自定义类加载器 / 如何自定义双亲委派机制 / 如何解决同类多版本加载冲突问题** [参考](https://www.cnblogs.com/wxd0108/p/6681618.html) [参考](https://www.cnblogs.com/straybirds/p/8456136.html)

<img src="https://upload-images.jianshu.io/upload_images/2154124-d5859f8e79069128?imageMogr2/auto-orient/strip%7CimageView2/2" alt="img" style="zoom: 33%;" />

- **loadClass函数**：实现双亲委派模型。判断是否有父加载器，有则由父加载器加载（即调用`parent.loadClass(name, false);`）没有则调用启动类加载器加载，都没有则调用当前类加载器的`findClass`方法来完成类加载。
- findClass函数：自定义类加载器（自定义时必须重写）
- defineClass函数：创建类对象，将字节流解析成JVM能够识别的Class对象
