### 概述

#### 输入网址 / 一次HTTP请求⭐

[参考](https://blog.csdn.net/qq_40804005/article/details/82876209)

![在这里插入图片描述](https://img-blog.csdn.net/20180928090731646?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODA0MDA1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（判断 url 是否合法，如果不合法会使用默认的搜索引擎进行搜索。如果输入的是一个域名，默认会加上一个 http 前缀。）　

- DNS域名解析，获取对应的IP地址：DNS解析过程……
- 浏览器向服务器请求建立链接，发起TCP的三次握手；
- 链接建立起来后，浏览器向服务器发送HTTP请求；
- 服务器响应HTTP请求，浏览器获得HTML代码；
- 浏览器解析HTML代码，并请求HTML代码中的资源（如js css 图片等）；
- 浏览器对页面进行渲染并呈现给用户。

> 若不是服务器推送，则需两次HTTP请求，反之一次即可 [参考](https://blog.csdn.net/qq_21430819/article/details/100627941)

#### 网络分层

- 国际标准化组织提出了 OSI 七层模型，理论完善，但复杂且不实用；学习网络原理使用五层模型；实际使用 TCP/IP 四层模型。　
- TCP/IP与OSI最大的不同在于：OSI是一个理论上的网络通信模型，而TCP/IP则是实际上的网络通信标准。

​                                        <img src="https://img2018.cnblogs.com/blog/1194208/201810/1194208-20181009114652839-1127682973.png" alt="img" style="zoom: 50%;" />                     

<img src="https://img-blog.csdn.net/20160126223713317" alt="这里写图片描述" style="zoom: 67%;" />

**1 物理层**

**功能**

- 实现了计算机节点之间**比特流**的透明传送
- 尽可能屏蔽掉具体传输介质和物理设备的差异，使数据链路层只需考虑本层协议和服务。

> 数据单位是比特，因此物理层需要考虑用多大的电压代表 1 或 0，以及接收方如何识别发送方所发送的比特。
>
> 还要确定传输媒体规范，例如接线器形状、电缆电压范围等。

**2 数据链路层**

**功能**

- 接收来自物理层的比特流数据，封装成**帧**并传送到上一层。

  每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。

- 将来自上层的数据帧拆装为比特流形式的数据转发到物理层。

**链路层协议**

- 点对点协议 PPP  

  在通信质量较差的年代使用高级数据链路控制 HDLC 作为数据链路层协议，目前使用最广泛的协议是 PPP。PPP 的特点是简单、只检测差错而不纠正、不使用序号也不进行流量控制、同时支持多种网络层协议。

- **CSMA/CD 协议**

  具有冲突检测的载波监听多点接入协议。特点是：发送前先监听、边发送边监听，一旦发现总线上出现了碰撞就立即停止发送，然后按退避算法等待一段随机时间后再次发送。

**3 网络层**

**功能**

选择合适的路由器，使源主机的分组通过路由器找到目的主机

**网络层协议**

- **网际协议 IP**

  一般指 IPv4，与 IP 配套使用的还有 ARP、ICMP 和 IGMP。

  IP 数据报分为首部和数据两部分。首部前 20 字节是固定的，包含源地址、目的地址、总长度等，生存时间限制了 IP 数据报在网络中能经过的最大路由数，防止其兜圈子。

  要解决 IP 地址耗尽的问题，根本方法是采用具有更大地址空间的 IPv6（128 位）。

- **地址解析协议 ARP** 

  ARP协议完成了**IP地址与物理地址的映射**

- 路由选择协议

  内部网关协议：

  - RIP：分布式的距离向量协议，适用于小型网络，按固定时间间隔与相邻路由器交换路由表信息。

  - OSPF：分布式的链路状态协议，适用于大型网络，只在链路状态变化时才向本自治系统中的所有路由器发送相邻路由器的信息。

  外部网关协议：

  - BGP-4：针对不同自治系统之间的路由器，目标是寻找一条能够到达目的网络且不兜圈子的路由。

- 网际控制报文协议 ICMP

  ICMP 报文包括差错报文和询问报文，ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。ICMP 允许主机或路由器报告差错情况，提供有关异常情况的信息。ICMP 的重要应用是分组探测 PING，测试主机间的连通性。

- 网际组管理协议 IGMP

  IGMP 的作用是让连接在本地局域网上的多播路由器知道本局域网上是否有主机的某个进程参加或退出了某个多播组。

**4 运输层**

**功能**

负责向两个主机中进程之间的 通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能

- 分用，把收到的信息交付给上面应用层中相应的进程
- 复用，多个应用层进程可同时使用下面运输层的服务

**运输层协议包括**

- **用户数据报协议 UDP**

  提供无连接的、尽最大努力交付的数据传输服务，不保证可靠性，传输单位是用户数据报。

- **传输控制协议 TCP**

  提供面向连接的数据传输服务、保证可靠性，传输单位是报文。

**5 应用层**

**功能**

为用户的应用进程提供网络通信服务

**应用层协议包括**

- **域名解析系统 DNS**

  DNS 是一个分布式数据库系统，存储了域名和 IP 地址的映射关系。

- 文件传送协议 FTP

  FTP 通过TCP 保证可靠运输，使用两个端口，控制端口 21 和数据端口 20，分别进行控制连接和数据连接。

- 电子邮件协议

  从用户代理把邮件传送到服务器，以及在服务器之间的传送使用 SMTP 协议。

  用户代理从服务器读取邮件时使用 POP3 或 IMAP 协议。

- **支持万维网应用的HTTP协议**

### ARP

#### MAC地址

**MAC定义及作用**

![img](https://img-blog.csdn.net/20180813204913248?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlbmppYW5xaTE2NDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 定义：物理地址（MAC）是数据链路层和物理层使用的地址；IP地址是网络层及其以上层使用的地址。
- 作用：ARP根据目的主机的IP地址查到其物理地址

**既然主机之间的连接最终通过MAC地址连接的为什么还要IP地址呢？**

- 为什么要MAC地址：每个主机的ip地址不固定而mac地址固定，故最终还是得靠MAC找到主机


- 为什么要IP地址：不同网络的主机通信时，通过IP地址（网络号）可以快速找到目标主机，减少查找的次数（不用疯狂遍历MAC）

#### ARP原理

**ARP协议的作用**

ARP协议完成了**IP地址与物理地址(MAC)的映射**

- 每台主机都会在自己的ARP缓冲区中建立一个**ARP列表**，表示IP地址和MAC地址的对应关系。
- 源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个**ARP请求**的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。
- 网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP 是否和自己的IP地址一致：如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；
- 源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输；如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

**ARP欺骗**

- 攻击者在局域网中一直处于监听状态。
- 如PC1与PC2通信，攻击者可以不断地发**ARP回复包**给PC1，把源IP设为PC2的IP地址，把MAC地址设为攻击者自己的MAC地址
- PC1收到后，会根据后到优先的原则，将原本要发送给PC2的数据包的MAC地址写入攻击者的MAC地址，把数据包发给攻击者 

### IP

#### 子网掩码

划分子网 (subnetting)：从 1985 年起在 IP 地址中增加了一个“子网号字段”，使两级 IP 地址变成三级 IP 地址：网络ID+子网ID+主机ID

- 作用：将一个较大的网络划分成若干个小的网络，减少IP地址的浪费

- 实现原理：ip地址和子网掩码进行按位与运算可以得出网段地址


#### IP地址

**IP地址分类**

<img src="https://images2018.cnblogs.com/blog/1440532/201809/1440532-20180912093201807-306001370.png" alt="img" style="zoom: 50%;" />

- A类：第一个字节为网络号，后三个字节为主机号。(1.0.0.0-126.0.0.0)（默认子网掩码：255.0.0.0或 0xFF000000）

  该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。

- B类：前两个字节为网络号，后两个字节为主机号。(128.0.0.0-191.255.0.0)（默认子网掩码：255.255.0.0或0xFFFF0000）

  该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。

- C类：前三个字节为网络号，最后一个字节为主机号。(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0或 0xFFFFFF00）

  该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。

- D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。

- E类：是保留地址。该类IP地址的最前面为“11110”，所以地址的网络号取值于240~255之间。

**特殊IP地址**

- 回送地址：系统诊断。如127.0.0.1用于回路测试
- 网路地址：网络本身。网络号正常，主机号全为0。如172.16.45.0就是一个B类网络地址
- 广播地址：广播网络中所有设备。网络号正常，主机号全为1（255），如172.16.45.255就是一个B类的网络地址
- 有限广播地址：本网广播。指的是32位全为1（即255.255.255.255）的IP地址。
- 私有地址：只能在局域网内使用。
  - 10.0.0.0-10.255.255.255，表示1个A类地址
  - 172.16.0.0-172.31.255.255 表示16个B类地址
  - 192.168.0.0-192.168.255.255表示256个C类地址
- 0.0.0.0已经不是真正意义上的ip地址，表示所有不清楚主机和目的网络。不清楚指在本机路由表里没有特定条目指明如何到达。

**IPV4和IPV6的区别** [参考](https://www.php.cn/windows-413502.html)

- 长度区别
- IPv6提供身份验证和加密，但IPv4不提供。

### TCP

#### 可靠性⭐

**TCP协议如何来保证传输的可靠性** [参考](https://www.jianshu.com/p/42dbcd39c3e7) 

- 序号：将每个字节的数据都进行了编号，本报文段所发数据第一个字节的序号
- 确认应答（确认号）：每次接收方收到数据后，都会对发送方进行确认应答，也就是发送ACK报文。ACK报文当中带有对应的确认号，  期望收到对方下个报文段所发数据第一个字节的序号，确认号为 N 代表到 N-1 的数据都已收到
- 检验和：检验包括首部和数据两部分，如果接收方检测到差错会丢弃 TCP 报文。
- 连接管理：TCP建立连接时的三次握手和断开连接时的四次挥手。
- 超时重传：报文发出后在一定的时间内未收到接收方的确认，发送方就会进行重传。
- 流量控制：让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。
- 拥塞控制：防止过多的数据注入到网络中，使网络中的路由器或链路不致于过载，是一个全局性问题    

#### 报文结构

TCP 报文段分为首部和数据两部分。首部的前 20 个字节固定，后面有 4n 字节根据需要增加。

![image-20210122183708735](https://i.loli.net/2021/01/22/muk7cjwnp53IW6E.png)

| 字段             | 大小     | 说明                                                         |
| ---------------- | -------- | ------------------------------------------------------------ |
| 源端口和目的端口 | 2B       | 分别写入源端口号和目的端口号（TCP 的分用功能是通过端口实现的） |
| **序号 seq**     | 4B       | 本报文段所发数据第一个字节的序号                             |
| **确认号 ack**   | 4B       | 期望收到对方下个报文段所发数据第一个字节的序号，确认号为 N 代表到 N-1 的数据都已收到 |
| 数据偏移         | 4b       | 指出了报文的数据起始处到报文起始处的距离，即首部长度，单位为4B。 |
| 保留             | 6b       | 保留为今后使用，但目前应置为 0。                             |
| 标志             | 6b       | **SYN**：同步，在建立连接时用来同步序号，SYN=1 表示一个连接请求或连接响应报文。 |
|                  |          | **ACK**：确认，ACK=1 时表示成功接收了报文段。                |
|                  |          | **FIN**：终止，用来释放连接，当 FIN=1 时表示发送方已发送完毕，并要求释放连接。 |
|                  |          | **RST**：复位，当 RST=1 时表示 TCP 连接出现了严重错误，必须释放再重新建立连接。 |
|                  |          | URG：紧急，URG=1 时表示存在紧急数据，该数据不再排队等待发送。需要和紧急指针配合使用。 |
|                  |          | PSH：推送，PSH=1 时接收方不再等待整个缓存填满再交付数据，而是尽快交付数据。 |
| 窗口             | 2B       | 接收方允许发送方的发送窗口大小                               |
| 检验和           | 2B       | 检验包括首部和数据两部分，如果接收方检测到差错会丢弃 TCP 报文。 |
| 紧急指针         | 2B       | URG=1时才有意义，指出本报文段中紧急数据的字节数。            |
|                  |          |                                                              |
| 选项             | 长度可变 | 最大报文段长度MSS、窗口扩大、时间戳、选择确认...             |
| 填充             |          | 为了使整个首部长度是 4 字节的整数倍                          |

**滑动窗口协议**

> 在超时重传、流量控制、拥塞控制使用……

滑动窗口以字节为单位

- “滑动”则是指这段发送的字节序是随着发送的过程而变化的，方式就是按顺序“滑动”。
- “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；

#### 连接管理⭐

**三次握手** [参考](https://blog.csdn.net/hyg0811/article/details/102366854)

<img src="https://i.loli.net/2021/04/03/QWalNvDL689ibGO.png" alt="image-20210403234115465" style="zoom:50%;" />

1. 客户端发送SYN 报文，处于 `SYN_SENT` 状态。  SYN=1，序号seq=x（随机）
2. 服务器发送SYN+ACK报文，处于 `SYN_RCVD` 状态，TCP处于**半连接状态**。 其中SYN=1，ACK=1，序号seq=y（随机），确认号ack=x+1。
3. 客户端发送ACK 报文，处于 `ESTABLISHED` 状态。服务器收到 ACK 报文之后，也处于 `ESTABLISHED` 状态。 其中ACK=1，序号seq=x+1，确认号ack=y+1

**为什么需要三次握手，两次不行吗？**

这是为了**防止已失效的连接请求报文**突然又传送到了服务端，产生错误。

- 若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了资源。
- 若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立连接

**TCP三次握手中第三次握手ACK失败了怎么办？服务端是否会重发？重发次数多少？**

当失败时服务器并不会重传ack报文，而是直接发送RST报文段，进入CLOSED状态。这样做的目的是为了防止SYN攻击。

**TCP洪泛攻击 / SYN攻击是什么？**

服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。

SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包。此时Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将**长时间占用未连接队列**，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DDoS 攻击。

防御方法（没有根治的方法，除非不用TCP）

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术

**如果服务端没接到第三个数据包但是客户端在发送了第三个数据包之后再发一个数据包怎么办？**

当失败时服务器并不会重传ack报文，而是直接发送RTS报文段，进入CLOSED状态。这样做的目的是为了防止SYN攻击。

故服务端不会接收此数据包。客户端会收到RTS报文段，明白对方关闭连接，需要重新建立连接。

**三次握手过程中可以携带数据吗？**

第三次握手可以携带数据。但是，**第一次、第二次握手不可以携带数据**

- 假如第一次握手可以携带数据，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，让服务器花费很多时间、空间来接收这些报文。
- 第三次的握手客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据

---

**四次挥手**

<img src="https://i.loli.net/2021/04/03/N5qGEzmcRjKPwYL.png" style="zoom:50%;" />

1. 客户端发送FIN 报文，处于 `FIN_WAIT1` 状态，主动关闭TCP连接。 FIN=1，序号seq=u（随机）
2. 服务端发送ACK 报文，处于 `CLOSE_WAIT`状态，TCP处于**半关闭状态**。 ACK=1，序号seq=v（随机），确认号ack=u+1。
3. 服务端发送FIN 报文，处于 `LAST_ACK` 状态。  FIN=1，ACK=1，序号seq=w（随机），确认号ack=u+1
4. 客户端发送ACK 报文，处于 `TIME_WAIT` 状态，服务端收到 ACK 报文后，处于 `CLOSED` 状态，关闭连接。 ACK=1，序号seq=u+1，确认号ack=w+1

**挥手为什么需要四次？**

主要是服务端为了传输剩余的报文。

- 握手时服务端收到客户端的SYN报文后，可以直接发送SYN+ACK报文。
- 但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我**服务端所有的报文**都发送完了，我才能发送FIN报文。故需要四次挥手。

**四次挥手释放连接时，等待2MSL（约4分钟）的意义?**

**MSL**是“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

- 防止**已失效的连接请求报文**出现在本连接中。再经过2MSL可以使本连接时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。
- 保证客户端发送的最后一个ACK报文能够到达服务端。因为可能因为网络不可靠，导致ACK报文丢失，此时**会重发**。

---

**TCP delayed ack / 延迟ACK**

接收方在收到数据后并不立即回复ACK，而是延迟一定时间或达到2x最大段数据长度为止 (不同操作系统实现并不一样)

目的是合并ACK，降低网络流量。

- 如果连续收到两个TCP包，并不一定需要ACK两次，只要回复最终的ACK就可以了。
- 如果接收方有数据要发送，那么就会在发送数据的TCP数据包里，带上ACK信息。

#### 超时重传

自动重传请求ARQ包括停止等待协议、回退 N 步协议和选择重传协议，后两种结合了窗口机制，属于**连续 ARQ 协议**。

**1 停止等待协议**

每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。通常 A 最终总是可以收到对所有发出分组的确认，如果 A 不断重传分组但总收不到确认，就说明通信线路质量太差，不能通信。分为3种情况：

- 无差错

  A 发送分组 M1，发送完后暂停并等待 B 的确认；B 收到 M1后向 A 发送确认；A 收到确认后再发送下一个分组 M2

- 出现差错

  B 收到 M1 后检测到了差错，或者 M1在传输过程中丢失，这两种情况下 B 都不会发送确认信息。解决方法是：A 每发送完一个分组就设置**超时计时器**，如果在计时器到期前收到确认就撤销计时；只要超过一段时间没有收到确认就进行超时重传。

  注意：① 发送完分组后必须暂时保留副本，收到确认再清除。② 分组和确认分组都必须进行编号。③ 超时时间应当比分组传输的往返时间稍长，过短会产生不必要的重传，过长会降低通信效率。

- 确认丢失和确认迟到 

  B 发送确认丢失，A 会超时重传，B 会丢弃重传分组并重新确认；B 发送的确认迟到，A 收到重复确认后将其丢弃。

停止等待协议的优点是简单，缺点是信道利用率低。

为提高传输效率，发送方可以连续发送多个分组，不必每发送完一个分组就停下来等待确认，使信道上一直有数据传送。包括回退 N 步和选择重传。

**2 回退 N 步协议**

回退 N 步即 GBN 协议，允许发送方发送多个分组而不需要等待确认。

- GBN 中已发送但还未确认的序号和允许发送但还未发送的序号可以被看作一个长度为 N 的窗口，随协议运行该窗口向前滑动，因此 GBN 也被称为滑动窗口协议。
- GBN 采用**累积确认**的方式，对按序到达的最后一个分组发送确认，如果超时，发送方会重传所有已发送但还未确认的分组。（例如发送了序号为 1~5 的五个分组，除了第三个全部收到了，那么确认序号就是 2，发送方将重传 3~5 的分组。）
- 在 GBN 中，接收方会丢弃所有失序分组，因为接收方必须按序交付数据。

优点是缓存简单，不需要缓存任何失序分组；缺点是对失序分组的重传可能出错而导致更多重传。

**3 选择重传协议**

选择重传即 SR 协议，让发送方仅重传那些它怀疑接收出错的分组，避免不必要的重传。接收方将确认一个正确接收的分组而不管其是否按序，失序分组将被缓存直到收到所有丢失分组。

---

**超时时间如何确定？**[参考](https://zhuanlan.zhihu.com/p/101702312)

TCP采用了一种自适应算法

- 记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的**往返时间RTT**
- 超时重传时间RTO (Retransmission Time-Out)应略大于**加权平均往返时间**

#### 流量控制

让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。

**流量控制原理**

接收窗口告诉发送方自己可用的缓存空间，发送方的发送窗口不能超过接收方的接收窗口。

**死锁情况**

当接收窗口=0 时就不再允许发送方发送数据，但可能存在一种死锁情况：

- 在发送**零窗口报文**不久后，若接收方的接收缓存又有了存储空间，会发送报文说明新的接收窗口。但若该报文在传输中丢失时，发送方会一直等待接收方的非零窗口通知，而接收方也一直在等待发送方发送数据，形成死锁。
- 为解决该问题，TCP 为每个连接设有**持续计时器**，只要一方收到零窗口通知，就启动该计时器，到期后发送一个零窗口探测报文，接收方发送现在的窗口值，避免死锁。

**糊涂窗口综合症**

- 当**接收方处理数据很慢**时，发送方能传输的有效数据会很小，（ 极端情况下有效数据只有 1B 但传输开销却有 40B（IP 首部及TCP 首部各占 20B) ），导致通信效率极低。

- 为解决该问题，可以等到接收方有足够空间容纳一个最长报文段，或接收缓存有一半空间再发送；发送方也不要发送太小的报文，而是把数据积累成足够大的报文，或达到接收方缓存一半时才发送。

#### 拥塞控制

**拥塞控制和流量控制不同**

- 拥塞控制是一个全局性的过程，服务端并不知道是哪个客户端造成的问题；而后者是点对点通信量的控制。
- 前者是因为在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能变坏即**拥塞**；后者是因为发送方发送得太快，接收方来不及接收。

**拥塞控制的四种算法**

慢开始门限**ssthresh**的用法如下：

- 当 cwnd < ssthresh 时，使用慢开始算法。
- 当 cwnd > ssthresh 时，改用拥塞避免算法。
- 当 cwnd = ssthresh 时，既可使用慢开始算法也可使用拥塞避免算法。

**1 慢开始**

cwnd < ssthresh 时，指数规律增加拥塞窗口的大小，不要一开始就发送大量的数据

**2 拥塞避免**

cwnd > ssthresh 时，每经过一个往返时间RTT就把拥塞窗口大小加1，按线性规律缓慢增长

<img src="https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYy56eWJ1bHVvLmNvbS9SaWNvMTIzL3doaTB5NXNiYzN0eDlxY2RwMHM1MzJndy8lRTYlODUlQTIlRTUlQkMlODAlRTUlQTclOEIlRTQlQjglOEUlRTYlOEIlQTUlRTUlQTElOUUlRTklODElQkYlRTUlODUlOEQucG5n?x-oss-process=image/format,png" alt="慢开始与拥塞避免.png-90.3kB" style="zoom:80%;" />

**3 快重传**

- 接收方在收到一个失序的报文段后就立即发出**重复确认**，而不要等到自己发送数据时再捎带确认。
- 当发送方连续收到三个重复确认时，应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

<img src="https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYy56eWJ1bHVvLmNvbS9SaWNvMTIzL3d1a3RkbXM5anRnNHM5bTRwZTVrY2JpcS8lRTUlQkYlQUIlRTklODclOEQlRTQlQkMlQTAuanBn?x-oss-process=image/format,png" alt="快重传.jpg-42.3kB" style="zoom:80%;" />

**4 快恢复**

快重传配合使用的还有快恢复算法

- 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半
- 将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。

<img src="https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYy56eWJ1bHVvLmNvbS9SaWNvMTIzLzkwYW0xdm1kNzQwOGVmMDBtYXY4cGZ6ay8lRTUlQkYlQUIlRTYlODElQTIlRTUlQTQlOEQuanBn?x-oss-process=image/format,png" alt="快恢复.jpg-52.9kB" style="zoom:80%;" />

### UDP

#### TCP UDP⭐

**TCP与UDP的区别**	

- TCP是可靠的；UDP是不可靠的；
- TCP是点对点通信；UDP支持一对一、一对多、多对一、多对多通信；
- TCP是面向连接的；UDP是无连接的
- TCP是面向字节流的；UDP是面向报文的；
- TCP比UDP效率低，因为传输中需要对数据确认、重发、排序等操作
- TCP首部开销（20个字节）比UDP的首部开销（8个字节）要大；

> TCP 提供全双工服务。允许通信双方的应用进程在任何时候发送数据。TCP 连接的两端都有发送缓存和接收缓存：发送时，应用程序把数据传送给 TCP 缓存后就可以做自己的事，TCP 在合适的时候发送；接收时，TCP 把收到的数据放入缓存，应用程序在合适的时候读取。

**TCP与UDP应用场景**

- TCP：效率要求低，但准确性要求高的场景。

  举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。

- UDP效率要求高，但准确性要求低的场景。

  举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）

**TCP UDP报文段的首部**

TCP……

<img src="https://img-blog.csdnimg.cn/20200125104810518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY0OTc2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" />

- 源端口号：在需要对方回信的时候选用，不需要的时候可用全0
- 目的端口号：这在终点交付报文时必须要使用到。
- 长度：UDP用户数据报的长度(首部字段和数据字段)，其最小值是8，也即是只有首部。
- 检验和：检测UDP用户数据报在传输的过程中是不是有错，有错就丢弃。

**TCP和UDP对应的应用层协议**

- TCP对应的协议：
  - HTTP：是从Web服务器传输超文本到本地浏览器的传送协议，端口默认80。
  - FTP：文件传输协议，使用21端口。
  - Telnet：远程登陆，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务
  - SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
  - POP3：邮件接收协议，和SMTP对应。POP3协议所用的是110端口。
- UDP对应的协议：
  - DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
  - SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
  - TFTP(Trival File TransferProtocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。

<img src="https://imgconvert.csdnimg.cn/aHR0cDovL3N0YXRpYy56eWJ1bHVvLmNvbS9SaWNvMTIzL3IzZ200ZTZ5OWhsZ3FsbHc4YmExMDY3Ni9UQ1AlRTUlOTIlOENVRFAlRTUlODglODYlRTUlODglQUIlRTUlQUYlQjklRTUlQkElOTQlRTclOUElODQlRTUlQjglQjglRTglQTclODElRTUlQkElOTQlRTclOTQlQTglRTUlQjElODIlRTUlOEQlOEYlRTglQUUlQUUucG5n?x-oss-process=image/format,png" alt="TCP和UDP分别对应的常见应用层协议.png-41.5kB" style="zoom:67%;" />

**TCP和UDP能不能同时监听同一个端口**

可以相同

因为TCP和UDP都在OSI的第四层，端口号就是第四层，也就是说端口只是TCP定义的数据而已，TCP端口和UDP端口就是两个传输层协议自己的东西，分别进行维护。tcp维护着tcp的端口列表，udp维护着udp的端口，所以不会冲突可以监听。

#### UDP实现可靠传输

**UDP可靠传输实现是怎样的？ / 如何同时拥有TCP UDP的优点** [参考](https://www.cnblogs.com/moxie-/p/13509000.html)

可以理解为本质上是在问TCP的可靠性原理。可以参照tcp可靠性原理，只是实现不在传输层，而是转移到了**应用层**。

- 实现确认机制、重传机制、窗口确认机制……
  - 添加seq/ack机制，确保数据发送到对端
  - 添加发送和接收缓冲区，主要是用户超时重传。
  - 其实就是参照**tcp可靠性**实现瞎扯
- 目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。

### DNS

#### DNS原理⭐

**DNS解析过程**

- 浏览器搜索自身的DNS缓存。缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存
- 若无，搜索操作系统的DNS缓存
- 若无，读取本地的Host文件（位于C:\Windows\System32\drivers\etc）
- 若无，向本地DNS服务器进行查询
  - 如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析（此解析具有权威性）
  - 若无，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）
  - 若无，则将根据其设置发起递归查询或者迭代查询

**DNS解析方式**

- 递归查询：由客户机向DNS服务器发出请求
  - 如果该DNS服务器为被授权的服务器，且它能够回应请求，则返回结果给客户机
  - 若不能，则该DNS服务器则**代替客户机**向它认为能给出结果的DNS服务器发出请求
  - 以此类推，得到结果后逐级返回。
- 迭代查询：由客户机向DNS服务器发出请求
  - 如果该DNS服务器为被授权的服务器，且它能够回应该请求，则返回给客户机
  - 若不能，则该DNS服务器则向客户机返回一个它认为能给出结果的DNS服务器地址，**客户机再向这个地址发出请求**
  - 以此类推，得到结果后逐级返回。

**在浏览器中输入 [www.douyin.com](https://www.nowcoder.com/discuss/www.douyin.com) 浏览器提示找不到 IP 地址是什么原因**

可能是DNS解析过程某一步出错？

**DNS用什么传输层协议**

DNS占用53号端口，同时使用TCP和UDP协议。

- **域名解析**：UDP
  - 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。
  - 不用经过三次握手，这样DNS服务器负载更低，响应更快。
  - 理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。
- **区域传输**：TCP
  - DNS负载均衡的数据同步传送的数据量比一个请求应答的数据量要多得多。
  - TCP是可靠连接，保证了数据的准确性。

#### DNS负载均衡

**DNS负载均衡的详细过程**



### HTTP 

#### HTTP概述

**HTTP和TCP有什么联系** [参考](https://blog.csdn.net/u013485792/article/details/52100533?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161716440216780271561593%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161716440216780271561593&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-2-52100533.pc_search_result_cache&utm_term=HTTP%E5%92%8CTCP%E7%9A%84%E8%81%94%E7%B3%BB)

- HTTP协议中的数据一般是利用TCP协议传输的，所以支持HTTP一般也支持TCP ； 
- HTTP是应用层协议，定义的是传输数据的内容的规范；TCP是网络层协议，定义的是数据传输和连接方式的规范；

**HTTP和RPC的区别，各适用范围**

- 协议：RPC是通常基于TCP/IP协议；HTTP基于HTTP协议
- 效率：RPC 比 HTTP效率高
- 复杂度：RPC 比 HTTP复杂。RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。
- RPC 通常在大型网站中使用。小型网站直接使用HTTP就可以了。

#### HTTP报文格式⭐

**请求报文** [参考](https://guisu.blog.csdn.net/article/details/8680808) [参考](https://blog.csdn.net/weixin_40803329/article/details/89843937)

<img src="https://img-blog.csdn.net/20170707143243946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGV5dWVfOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="在这里插入图片描述" style="zoom:67%;" />

**1 请求行**

①请求方法

②请求URL。它和报文头的Host属性组成完整的URL

③HTTP协议及版本

| 方法    | 描述                                                         |
| :------ | :----------------------------------------------------------- |
| GET     | 请求指定的页面信息，并返回实体主体。                         |
| HEAD    | 用于获取报头。类似于 GET 请求，只不过返回的响应中没有具体的内容 |
| POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
|         | HTTP1.1新增                                                  |
| PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
| PATCH   | 局部更新。是对 PUT 方法的补充                                |
| DELETE  | 请求服务器删除指定的页面。                                   |
| CONNECT | HTTP/1.1 中预留给能够将连接改为管道方式的代理服务器。        |
| OPTIONS | 客户端查看服务器的性能                                       |
| TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |

**Get与POST的区别⭐**[参考](https://blog.csdn.net/zzk220106/article/details/78595108?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6.not_use_machine_learn_pai)

- POST比GET安全。因为POST提交的内容不会作为url的一部分，不会被缓存，不会被保存在服务器日志、以及浏览器浏览记录中
- GET一般用来从服务器上获取资源；POST一般用来更新服务器上的资源
- GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小；POST请求则是没有大小限制的。
- POST比GET慢
  - POST在真正发送数据之前会先将请求头发送给服务器进行确认OPTION，然后才发送数据
  - POST请求包含更多的请求头
  - GET会将数据缓存起来，而POST不会
  - POST不能进行管道化传输。管道把需要发送到服务器上的所有请求放到输出队列中，在第一个请求发送出去后，不等到收到服务器的应答，第二个请求紧接着就发送出去，但存在不安全的问题。

**2 请求头** [参考](http://tools.jb51.net/table/http_header)

④包含若干个属性，格式为“属性名:属性值”

| Header        | 解释                                         | 示例                                              |
| :------------ | :------------------------------------------- | :------------------------------------------------ |
| Accept        | 客户端能够接收的内容类型                     | Accept: text/plain, text/html                     |
| Authorization | HTTP的授权证书                               | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== |
| Cache-Control | 请求和响应遵循的缓存机制                     | Cache-Control: no-cache                           |
| Connection    | 是否长连接。（HTTP 1.1默认长连接）           | Connection: close                                 |
| Cookie        | 把该请求域名下的所有cookie值发送给服务器     | Cookie: $Version=1; Skin=new;                     |
| Content-Type  | 请求的与实体对应的MIME信息                   | Content-Type: application/x-www-form-urlencoded   |
| Host          | 请求的服务器的域名和端口号                   | Host: www.zcmhi.com                               |
| Range         | 只请求实体的一部分，指定范围                 | Range: bytes=500-999                              |
| Referer       | 先前网页的地址，当前请求网页紧随其后，即来路 | Referer: http://www.zcmhi.com/archives/71.html    |
| User-Agent    | 发出请求的用户信息                           | User-Agent: Mozilla/5.0 (Linux; X11)              |

**3 请求体**

- POST请求参数在请求体处，较安全
- GET将请求参数追加在url后面，无请求体，不安全

---

**响应报文**

![img](https://img-blog.csdn.net/20180926113041788?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODA4NzUzOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**1 响应行**

①HTTP协议及版本

②状态码及状态描述

| 状态码  | 英文名称                   | 中文描述                                                     |
| :------ | :------------------------- | :----------------------------------------------------------- |
| **1XX** |                            | 信息。服务器收到请求，需要请求者继续执行操作                 |
| 100     | Continue                   | 继续。客户端应继续其请求                                     |
| **2XX** |                            | 成功。操作被成功接收并处理                                   |
| 200     | OK                         | 请求成功。一般用于GET与POST请求                              |
| 201     | Created                    | 已创建。成功请求并创建新资源                                 |
| 202     | Accepted                   | 已接受。已接受请求但未处理完成                               |
| **3XX** |                            | 重定向。需要进一步的操作以完成请求                           |
| 300     | Multiple Choices           | 多种重定向。请求的资源包括多个位置，可返回一个地址列表供客户端选择 |
| 301     | Moved Permanently          | 永久重定向。请求的资源被永久移动到新URI，客户端会修改并自动定向到新URI |
| 302     | Found                      | 临时重定向。与301类似，但资源只是临时移动，客户端继续使用原有URI |
| 303     | See Other                  | 查看其它地址。与301类似，使用GET和POST请求查看               |
| 304     | Not Modified               | 未修改。所请求的资源未修改，可使用缓存                       |
| 305     | Use Proxy                  | 使用代理。所请求的资源必须通过代理访问                       |
| **4XX** |                            | 客户端错误。请求包含语法错误或无法完成请求                   |
| 400     | Bad Request                | 请求语法错误，服务器无法理解                                 |
| 401     | Unauthorized               | 未认证                                                       |
| 402     | Payment Required           | 保留，将来使用                                               |
| 403     | Forbidden                  | 请求的资源被禁止访问                                         |
| 404     | Not Found                  | 请求的资源未找到                                             |
| 405     | Method Not Allowed         | 请求的方法被禁止                                             |
| **5XX** |                            | 服务器错误。服务器在处理请求的过程中发生了错误               |
| 500     | Internal Server Error      | 服务器内部错误，无法完成请求                                 |
| 501     | Not Implemented            | 服务器不支持请求的功能，无法完成请求                         |
| 502     | Bad Gateway                | 网关错误。作为网关或代理的服务器，从远程服务器收到了一个无效响应。 |
| 503     | Service Unavailable        | 系统正忙                                                     |
| 504     | Gateway Time-out           | 作为网关或代理的服务器，未及时从远端服务器获取请求           |
| 505     | HTTP Version not supported | 服务器不支持请求的HTTP协议的版本                             |

**遇到错误的排查思路**

- 50x直接去看服务器日志 
- 400一般请求参数错误
- 401权限错误
- 404检查url或项目配置

**2 响应头** [参考](http://tools.jb51.net/table/http_header)

③包含若干个属性，格式为“属性名:属性值”。缓存相关的规则信息、token

| Header        | 解释                                                | 示例                                            |
| :------------ | :-------------------------------------------------- | :---------------------------------------------- |
| Cache-Control | 告诉所有的缓存机制是否可以缓存及哪种类型            | Cache-Control: no-cache                         |
| ETag          | 请求变量的实体标签的当前值                          | ETag: “737060cd8c284d8af7ad3082f209582d”        |
| Expires       | 响应过期的日期和时间                                | Expires: Thu, 01 Dec 2010 16:00:00 GMT          |
| Last-Modified | 请求资源的最后修改时间                              | Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT    |
| Location      | 重定向接收方到非请求URL的位置来完成请求或标识新资源 | Location: http://www.zcmhi.com/archives/94.html |

**3 响应体**

④所请求的对象本身。浏览器将正文加载到内存，然后解析渲染显示页面内容

#### HTTP版本迭代⭐

**HTTP1.0和HTTP1.1的区别**

- **长连接**

  - HTTP/1.0默认使用短连接。客户端和服务器每进行一次HTTP操作就建立一次连接，任务结束就中断连接。可Keep-Alive设置长

  - HTTP/1.1起默认使用长连接。用以保持连接特性，减少建立和关闭连接的消耗和延迟

- **缓存处理**
  
  - HTTP1.0主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准
  - HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等
  
- **断点续传**
  
  - HTTP 1.1默认支持断点续传。断点续传其实就是在上一次下载断开的位置开始继续下载，可以在请求报文头中加入**Range**段，来表示客户机希望从何处继续下载。

- 节约带宽
  
  - HTTP1.0存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。
  - HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。
  
- HOST域
  - HTTP1.0认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名，没有host域。
  - HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。

- 错误通知管理
  
  -  HTTP1.1新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

**HTTP1.1和HTTP2.0的区别**

- **多路复用**
  - HTTP1.1可以多建立几个TCP连接处理多个并发请求，但是创建TCP连接本身是有开销的。
  - HTTP2.0使用了多路复用技术，同一个连接能处理多个并发请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
  
- **头部数据压缩**
  - 一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。导致消耗在头部的流量越来越多，完全是一种浪费。
    
  - HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。

- **服务器推送**
  - HTTP1.1中网络资源每一个都必须明确地请求，速度很慢
  - HTTP2.0引入了服务器推送，允许服务端推送资源给浏览器，免得客户端再次创建连接请求。这样客户端可以直接从本地加载这些资源，不用再通过网络。

<img src="https://img-blog.csdnimg.cn/20190730231423477.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FpbHVubGVl,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" />

**Http3.0 QUIC协议** [参考](https://blog.csdn.net/wolfGuiDao/article/details/108729560)

- **UDP实现**
- **解决队头阻塞问题**：http 2.0中前一个stream丢包会导致后一个stream被阻塞；QUIC 一个连接上的多个 stream 之间没有依赖，不会影响 stream2 之前及之后的 stream 的处理
- **连接迁移**：TCP使用五元组表示连接，网络环境变化时必须创建新的TCP连接；QUIC 使用一个64位随机数来确定这个连接
- 优化重传策略：QUIC 重传包和原包的编号不同，降低后续重传计算的消耗

#### HTTP状态保持⭐

HTTP 是一种**无状态**（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。

**1 基于Session实现的会话保持（登录）**

session的中文翻译是“会话”

- 在会话开始时，客户端第一次向服务器发送http请求
- **服务器将会话状态保存起来**（本机内存或数据库中），然后分配一个会话标识 SessionId 保存在客户端Cookie中
- 以后每次浏览器发送http请求都会带上Cookie中的SessionId到服务器
- 服务器拿到会话标识就可以把存储在服务器端的状态信息与会话联系起来，实现会话保持

<img src="https://img2018.cnblogs.com/blog/1600375/201906/1600375-20190621203925944-977861065.png" alt="img" style="zoom: 50%;" />

> 如果遇到浏览器禁用Cookie的情况，则可以通过url重写的方式将会话标识放在url的参数
>
> 当客户端存储的cookie失效后，服务端的session不会立即销毁，会有一个延时，服务端会定期清理无效session，不会造成无效数据占用存储空间的问题。
>

**问题**

- 内存占用：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。越来越多的用户发请求时，内存的开销也会不断增加
- 可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成一些拥堵。
- CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。
- CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。

**session共享的解决方案 / 单点登录SSO / 有两台服务器A，B，用户在服务器A登陆后，服务器B如何知道其为合法用户？** [参考](https://blog.51cto.com/10983206/2563806) [参考](https://www.cnblogs.com/daofaziran/p/10933221.html)

当服务器不止一台，就需要session共享，避免多次登录。

- 客户端存储：将session存储在浏览器cookie中

  优点：服务端不需要存储session，不会出现session不一致的问题

  缺点：存储在客户端不安全，并且每次请求都携带session，占用宽带，并且存储大小受到浏览器的限制。

- 粘性session：同一个用户的session绑定到某台服务器，用户请求时负载均衡器将其转发到绑定的服务器上

  实现：使用nginx的负载均衡，采用ip_hash算法，将用户绑定到固定的服务器上，实现session一致性

  优点：简单，不需要特殊处理

  缺点：缺乏容错性，当服务器发生故障，会导致session丢失

- session复制：每个服务器都保存一份session，有一台服务器session发生改变时，进行广播以保证session同步

  实现：开启tomcat的集群配置实现

  优点：可容错，各服务器session能够实时响应

  缺点：服务器压力大，当session量大的话，会拖慢服务器性能

- **Terracotta实现session复制**：一个节点发生变化时只把变化部分发送给Terracotta服务器，然后由服务器转发给真正需要这个数据的节点，属于session复制的优化

- session持久化：使用专门的数据库存储session，但访问量大时会对数据库造成比较大的压力

- **session共享**：使用分布式缓存方案如memcached、redis，但要求是集群环境

  粘性session共享：每个用户的session绑定到一个tomcat上，memcached/redis作为备份

  非粘性session共享：tomcat本身不存储session，而是存入memcached/redis中，memcached/redis集群构建主从复制架构

**2 基于Cookie实现的会话保持**

cookie是保存在本地终端的数据。cookie的组成有：名称(key)、值(value)、有效域(domain)、路径(域的路径，一般设置为全局:"\")、失效时间、安全标志(指定后，cookie只有在使用SSL连接时才发送到服务器(https)。

- cookie由服务器生成，发送给浏览器
- 浏览器把cookie以kv形式保存到某个目录下的文本文件内。
- 下一次请求同一网站时会把该cookie发送给服务器。

**3 基于Token实现的会话保持**

见项目笔记

---

**Session 与 Cookie 的对比**⭐

- 安全性：Session相对更加安全，保存在服务端；Cookie存在安全隐患，通过拦截或使用本地文件得到cookie后可以进行攻击
- 大小限制：Session没有大小限制，理论上只与服务器内存大小有关；Cookie有4K大小的限制并且浏览器对每个站点也有个数限制
- 服务器资源消耗：Session保存在服务端上，会存在一段时间才会清除，如果session过多会增加服务器的压力。
- 实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；
- 验证流程不同：背诵……

**Session 与 Token的对比**

-  token比session安全，因为token每个请求都有签名还能防止监听以及重放攻击（而session就必须靠链路层来保障通讯安全）
-  时间与空间的博弈：session是空间换时间，而token是时间换空间（加密解密）。
-  验证流程不同：背诵……

#### HTTP幂等性

**幂等性是什么** [参考](https://cloud.tencent.com/developer/ask/217917) [参考](https://www.cnblogs.com/weidagang2046/archive/2011/06/04/2063696.html)

幂等性是指一次和多次请求资源对资源本身应具有同样的结果

> 一次和多次请求某一个资源应该具有**同样的副作用**。副作用指发送完一个请求以后，网站上的资源状态发生修改

![image-20210415203325739](https://i.loli.net/2021/04/15/FxY2Thw8iDRcX3P.png)

**为什么要幂等性**

使用幂等性最大的优势在于使接口保证任何幂等性操作，免去因重试等造成系统产生的未知的问题。

- 前端重复提交表单……
- 接口超时重复提交……

**如何实现幂等性** [参考](https://blog.csdn.net/u011635492/article/details/81058153?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control) [参考](https://www.sohu.com/a/284541897_100028126)

参照RocketMQ

#### RESTful规范

**RESTful了解吗？**[参考](https://zhuanlan.zhihu.com/p/56955812) [参考](https://www.zhihu.com/question/31466196)

RESTful是一种设计模式，或者说是一种设计规范，它并没有太多强制性的要求之类的，实际上它有的只是几个原则，当一个应用满足这些原则的时候，可以认为它是RESTful的。

- 模型表示（Representations）
- 消息（Messages）
- URIs
- 一致接口（Uniform interface）
- 无状态（Stateless）
- 资源之间的链接（Links between resources）
- 缓存（Caching）

**用RESTful规范有什么好处？**

RESTful可以认为是一种建立在HTTP协议之上的设计模式，充分的利用了HTTP协议的特定，使用URL来表示资源，用各个不同的HTTP动词来表示对资源的各种行为。这样做的好处就是资源和操作分离，让资源的管理更加规范。

### HTTPS

#### HTTPS原理⭐

**HTTPS与HTTP区别⭐**

- HTTPS是具有安全性的SSL加密传输协议；HTTP协议是超文本传输协议，信息是明文传输的
- HTTPS协议需要CA证书，费用较高；HTTP协议不需要
- HTTPS的协议端口是443；HTTP协议端口是80

**HTTPS 流程 / 知道HTTPS的证书具体是怎么交换的吗 / HTTPS 的秘钥交换过程?** [参考](https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78507762) [参考](https://zhuanlan.zhihu.com/p/96494976)

<img src="https://imgconvert.csdnimg.cn/aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXpfcG5nL0JhcTVsWXBJdzdVbW8yVUpmNkFFZkNsN0VpYXg1WmY0QllhYklRZWpVaWJ1UWx2V2VDdlM5cXBFRGliNTlyV3M4R3NYQ0V3ZjdiRXNyOXJwZWVuRFBFakhnLzY0MA?x-oss-process=image/format,png" alt="img" style="zoom:50%;" />

- 证书验证阶段：**非对称加密**
  - 客户端发起HTTPS请求，要求与服务器建立SSL连接
  - 服务器收到请求后，生成一对公钥和私钥；把公钥放在证书中，并发给客户端
  - 客户端**验证证书**是否合法，如果不合法则提示告警
- 数据传输阶段：**对称加密**
  - 客户端在本地生成随机数，公钥加密后发给服务端
  - 服务端私钥解密随机数，根据随机数构造对称加密算法
  - 双方根据对称加密算法传输数据

---

**证书包含什么信息？**

数字证书是一个经证书授权中心CA数字签名的包含公开密钥拥有者信息以及公开密钥的文件，只在特定的时间段内有效。

最简单的证书包含一个公钥、名称以及证书授权中心的数字签名。

**为什么需要CA认证机构颁发证书？/ 中间人攻击**
                               <img src="https://img-blog.csdnimg.cn/img_convert/5d77e0f6df27cc9cfe26210167841ec1.png" alt="img" style="zoom:67%;" />                                

假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的 “中间人攻击” 问题。 

中间人和客户端建立通道，然后获取客户端的请求信息代发，最后骗取服务端的返回信息

1. 本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器
2. 中间人服务器返回中间人自己的证书
3. 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输
4. 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密
5. 中间人以客户端的请求内容再向正规网站发起请求
6. 因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据
7. 中间人凭借与正规网站建立的对称加密算法对内容进行解密
8. 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输
9. 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密

**如何验证证书的合法性**

- 验证域名、有效期等信息是否正确。
- 判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验
- 判断证书是否被篡改。需要与 CA 服务器进行校验；
- 判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率

**如何避免证书冒用的情况？**

证书采用非对称加密算法。

虽然中间人可以得到证书及其公钥，但公钥不可能推算出其对应的私钥，因此无法对客户端传入的加密数据进行解密。

---

**为什么要用对称加密传输数据**

- 对称加密效率比较高
- 如果使用非对称机密，则每个客户端都有自己的私钥。这明显不合理，因为私钥是需要申请的。

**为什么对称加密比非对称加密快** [参考](https://blog.csdn.net/qq_33419925/article/details/107659057)

- 对称加密主要的运算是**位运算**，速度非常快，如果使用硬件计算，速度会更快。如AES 算法其运算本质上来说就是位移和替换；

  非对称加密计算一般都比较复杂，比如 RSA，它里面涉及到大数乘法、大数模等等运算。

- AES 中的许多中间计算过程是可以事先计算好的。加密数据时许多中间过程可以直接查表，而不需要实时地计算。

**本地随机数被窃取怎么办？**

HTTPS只能保证传输过程的安全

而随机数存储于本地，属于本地安全这另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。

**TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？**

因为 SSL 的协议默认不信任每个主机都能产生完全随机的数，如果只使用一个伪随机的数来生成秘钥，就很容易被破解。

一个伪随机可能被破解，但是三个伪随机就很接近于随机了，保持生成秘钥的随机性和安全性。

---

**用了HTTPS可以被抓包吗？/ HTTPS 之后还会出现问题么？出现问题了怎么办?**

会。HTTPS 只防止用户在不知情的情况下通信被监听。如果用户主动授信，可以构建“中间人”网络，代理软件可以对传输内容进行解密。

要防止被抓包，需要采用应用级的安全防护。例如采用私有的对称加密，同时做好移动端的防反编译加固，防止本地算法被破解

> 通常HTTPS抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。

#### 加密算法

**加密算法有哪些，各适用哪些场？** [参考](https://blog.csdn.net/itfly8/article/details/104204874)

**1 对称加密算法**

采用单密钥的加密方法，同一个密钥可以同时用作信息的加密和解密，即解密算法为加密算法的逆算法。

AES算法：速度快，安全级别高，支持128、192、256、512位密钥的加密。

使用场景

- 无需进行密钥交换的场景，如内部系统，事先就可以直接确定密钥
- 防止明文传输数据被窃取的
- 加解密速度快，适合数据内容比较大的加密场景

**2 非对称加密算法**

采用的是公钥和私钥相结合的加密方法。公钥加密，私钥解密。同时这两个密钥在数学上是无关联的，在知道了加密算法后也无法知道解密算法，保证了安全性。

RSA算法：对极大整数做因数分解的难度决定了RSA算法的可靠性。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。

使用场景

- 适用于需要密钥交换的场景，如互联网应用，无法事先约定密钥
- 与对称加密算法结合。利用非对称加密算法安全性较好的特点，传递对称加密算法的密钥。利用对称加密算法加解密速度快的特点，进行数据内容比较大的加密场景的加密。如HTTPS。

**3 数字摘要算法**

是一种单向算法，通过对数据内容进行散列得到一个固定长度的密文信息。该算法不可逆，即用户可以通过哈希算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个Hash值重新获得目标信息。

MD5：一种被广泛使用的密码散列函数，可以产生出一个128位的散列值，用于确保信息传输完整一致。（王小云教授采用碰撞算法验证了MD5可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。）

使用场景

- 下载文件时，文件的完整性校验
- 接口交互时，交互数据的完整性校验
- 数字证书的指纹生成算法
- 密码的正确性校验，即只需要验证密码的摘要是否相同即可确认密码是否相同，同时也保证让密码以密文保存，无法被可逆破解
